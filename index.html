<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<title>–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ç–æ—Ä –¥–æ–º–∞</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
:root { --bg:#fff; --card:#d9d9d9; --text:#000; --r:12px; }
body { font-family:'Roboto',sans-serif; background:#e0e0e0; display:flex; justify-content:center; min-height:100vh; }
.app { width:100%; max-width:480px; background:var(--bg); min-height:100vh; display:flex; flex-direction:column; }

/* –ü–†–û–ì–†–ï–°–° */
.prog-wrap { padding:14px 36px 0; flex-shrink:0; }
.prog-lbl { font-size:12px; color:#999; text-align:right; margin-bottom:4px; }
.prog-bar { height:3px; background:#e0e0e0; border-radius:2px; overflow:hidden; }
.prog-fill { height:100%; background:#000; border-radius:2px; transition:width .4s; }

/* –≠–ö–†–ê–ù–´ */
.screen { display:none; flex-direction:column; flex:1; }
.screen.active { display:flex; animation:sIn .2s ease; }
@keyframes sIn { from{opacity:0;transform:translateX(16px)} to{opacity:1;transform:none} }
.sh { padding:18px 36px 12px; flex-shrink:0; }
.st { font-size:28px; font-weight:700; line-height:1.2; }
.ss { font-size:16px; font-weight:300; color:#666; margin-top:3px; }
.sb { flex:1; padding:0 36px 12px; overflow-y:auto; }

/* –ù–ê–í–ò–ì–ê–¶–ò–Ø */
.nav-row { display:flex; gap:10px; margin:0 36px 24px; flex-shrink:0; }
.btn-back { width:60px; height:60px; flex-shrink:0; background:var(--card); border:none;
  border-radius:var(--r); font-size:22px; cursor:pointer; display:flex; align-items:center;
  justify-content:center; transition:background .15s, transform .1s; }
.btn-back:active { background:#bbb; transform:scale(.97); }
.btn-next { flex:1; height:60px; display:flex; align-items:center; justify-content:space-between;
  padding:0 20px; background:var(--card); border:none; border-radius:var(--r);
  font-size:22px; font-weight:700; letter-spacing:.04em; color:var(--text);
  cursor:pointer; transition:background .15s, transform .1s; }
.btn-next:active { background:#bbb; transform:scale(.98); }
.btn-full { display:flex; align-items:center; justify-content:space-between;
  margin:0 36px 24px; padding:0 20px; height:60px; background:var(--card); border:none;
  border-radius:var(--r); font-size:22px; font-weight:700; letter-spacing:.04em; color:var(--text);
  cursor:pointer; flex-shrink:0; transition:background .15s, transform .1s; }
.btn-full:active { background:#bbb; transform:scale(.98); }
.btn-icon { width:60px; height:60px; flex-shrink:0; background:var(--card); border:none;
  border-radius:var(--r); font-size:24px; cursor:pointer; display:flex; align-items:center;
  justify-content:center; transition:background .15s; }
.btn-icon.on { background:#000; color:#fff; }

/* –®–ê–ì 1 */
.house-cards { display:flex; flex-direction:column; gap:12px; }
.house-card { position:relative; width:100%; height:130px; background:var(--card);
  border-radius:var(--r); cursor:pointer; overflow:hidden;
  border:3px solid transparent; transition:border-color .2s, transform .12s; }
.house-card:active { transform:scale(.99); }
.house-card.selected { border-color:#000; }
.house-card.selected::after { content:'‚úì'; position:absolute; top:10px; right:12px;
  width:26px; height:26px; background:#000; color:#fff; border-radius:50%;
  display:flex; align-items:center; justify-content:center; font-size:13px; font-weight:700; }
.hcp { width:100%; height:100%; display:flex; align-items:center; justify-content:center;
  flex-direction:column; gap:5px; color:#999; font-size:13px; font-weight:300; text-align:center; padding:12px; }
.hcp .ic { font-size:26px; opacity:.3; }
.hcl { position:absolute; bottom:0; left:0; right:0; padding:7px 14px;
  background:rgba(0,0,0,.5); color:#fff; font-size:14px; font-weight:500; }
.upload-card { width:100%; height:72px; background:var(--card); border-radius:var(--r);
  border:3px dashed #aaa; display:flex; align-items:center; justify-content:center;
  gap:10px; cursor:pointer; transition:background .2s; }
.upload-card:active { background:#bbb; }
.upload-card span { font-size:14px; font-weight:300; color:#666; }
#upload-input { display:none; }

/* 3D –°–õ–û–¢ (—à–∞–≥–∏ 2-4 –∏ 10) */
.view3d-slot { width:100%; aspect-ratio:1; background:var(--card); border-radius:var(--r);
  margin-bottom:16px; position:relative; overflow:hidden; }
.p-row { display:flex; align-items:center; justify-content:space-between; margin-bottom:12px; gap:10px; }
.p-lbl { font-size:16px; font-weight:300; flex:1; }
.p-inp { width:74px; height:38px; background:var(--card); border:none; border-radius:8px;
  text-align:center; font-size:18px; outline:none; flex-shrink:0; transition:background .15s; }
.p-inp:focus { background:#c0c0c0; }

/* –ß–ï–ö–õ–ò–°–¢ */
.checklist { display:flex; flex-direction:column; gap:9px; }
.ci { display:flex; align-items:center; justify-content:space-between;
  height:52px; padding:0 16px; background:var(--card);
  border-radius:var(--r); cursor:pointer; border:3px solid transparent;
  transition:border-color .2s; user-select:none; }
.ci:active { background:#c8c8c8; }
.ci.checked { border-color:#000; }
.ci-text { font-size:16px; font-weight:700; letter-spacing:.02em; }
.cb { width:22px; height:22px; border:3px solid #999; border-radius:5px;
  flex-shrink:0; position:relative; transition:background .15s, border-color .15s; }
.ci.checked .cb { background:#000; border-color:#000; }
.ci.checked .cb::after { content:''; position:absolute; left:3px; top:6px;
  width:9px; height:5px; border-left:2px solid #fff; border-bottom:2px solid #fff; transform:rotate(-45deg); }

/* –ö–ê–ù–í–ê–° */
.cv-hint { font-size:12px; color:#999; text-align:center; margin-bottom:6px; }
.cv-wrap { position:relative; width:100%; aspect-ratio:1; background:var(--card);
  border-radius:var(--r); margin-bottom:10px; overflow:hidden; touch-action:none; cursor:crosshair; }
.cv-wrap canvas { position:absolute; inset:0; width:100%; height:100%; display:block; }
.cv-acts { display:flex; gap:10px; margin-bottom:10px; }
.btn-u,.btn-c { flex:1; height:36px; background:var(--card); border:none; border-radius:8px;
  font-size:13px; font-weight:600; cursor:pointer; transition:background .15s; }
.btn-u:active,.btn-c:active { background:#bbb; }

/* –¢–û–ì–õ–´ */
.tg { display:flex; align-items:center; justify-content:space-between;
  height:50px; padding:0 16px; background:var(--card);
  border-radius:var(--r); cursor:pointer; border:3px solid transparent;
  transition:border-color .2s; user-select:none; margin-bottom:9px; }
.tg.on { border-color:#000; }
.tg-txt { font-size:16px; font-weight:700; }
.tg-ind { width:40px; height:20px; background:#bbb; border-radius:10px; position:relative; transition:background .2s; }
.tg.on .tg-ind { background:#000; }
.tg-ind::after { content:''; position:absolute; top:2px; left:2px;
  width:16px; height:16px; background:#fff; border-radius:50%; transition:transform .2s; }
.tg.on .tg-ind::after { transform:translateX(20px); }

/* –®–ê–ì 10 */
.sec-nav { display:flex; gap:7px; margin-bottom:10px; overflow-x:auto; padding-bottom:3px; }
.sec-nav::-webkit-scrollbar { display:none; }
.sec-tab { flex-shrink:0; padding:4px 12px; background:var(--card); border-radius:14px;
  font-size:12px; font-weight:600; cursor:pointer; border:2px solid transparent;
  white-space:nowrap; transition:background .15s, border-color .15s; }
.sec-tab.active { border-color:#000; background:#f0f0f0; }
.view3d { width:100%; aspect-ratio:1; background:var(--card); border-radius:var(--r);
  display:flex; align-items:center; justify-content:center; margin-bottom:10px;
  color:#999; font-size:16px; font-weight:300; position:relative; overflow:hidden; }
.arr { position:absolute; top:50%; transform:translateY(-50%);
  width:32px; height:32px; background:rgba(0,0,0,.18); border-radius:50%;
  display:flex; align-items:center; justify-content:center; font-size:16px; cursor:pointer; border:none; }
.arr.l{left:8px} .arr.r{right:8px}
/* –û–ë–†–ê–ó–¶–´ ‚Äî —Å–µ—Ç–∫–∞ –∫–≤–∞–¥—Ä–∞—Ç–∏–∫–æ–≤ */
.sample-lbl { font-size:12px; color:#999; margin-bottom:8px; }
.samples-grid { display:flex; flex-wrap:wrap; gap:8px; margin-bottom:12px; }
.swatch { width:72px; height:72px; background:var(--card); border-radius:10px;
  border:2px solid #ccc; display:flex; align-items:center; justify-content:center;
  flex-direction:column; gap:4px; cursor:default; position:relative; }
.swatch-name { font-size:9px; font-weight:600; color:#555; text-align:center;
  line-height:1.2; padding:0 4px; }
.swatch-del { position:absolute; top:2px; right:3px; font-size:10px; color:#aaa;
  cursor:pointer; line-height:1; background:none; border:none; padding:0; }
.swatch-del:hover { color:#000; }
.swatch-active { box-shadow:0 0 0 3px #fff, 0 0 0 5px #000; border-color:#000 !important; }
.samples-empty { font-size:13px; color:#bbb; font-weight:300; }

/* –ö–ê–¢–ê–õ–û–ì ‚Äî –§–ò–õ–¨–¢–†–´ */
.filter-section { margin-bottom:18px; }
.filter-title { font-size:14px; font-weight:700; margin-bottom:10px; color:#333; letter-spacing:.03em; }
.color-grid { display:grid; grid-template-columns:repeat(8,1fr); gap:8px; margin-bottom:4px; }
.color-dot { width:100%; aspect-ratio:1; border-radius:50%; cursor:pointer;
  border:3px solid transparent; transition:border-color .15s, transform .12s;
  box-shadow:0 1px 3px rgba(0,0,0,.2); }
.color-dot:active { transform:scale(.9); }
.color-dot.selected { border-color:#000; box-shadow:0 0 0 3px #fff, 0 0 0 5px #000; }
.price-btns { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
.price-btn { height:52px; background:var(--card); border:3px solid transparent;
  border-radius:var(--r); font-size:14px; font-weight:700; cursor:pointer;
  transition:border-color .2s, background .15s; line-height:1.3; padding:4px 8px; }
.price-btn:active { background:#bbb; }
.price-btn.selected { border-color:#000; background:#f0f0f0; }
.filter-divider { height:1px; background:#e8e8e8; margin:16px 0; }

/* –ö–ê–¢–ê–õ–û–ì ‚Äî –†–ï–ó–£–õ–¨–¢–ê–¢–´ */
.cat-results { display:flex; flex-direction:column; gap:10px; }
.mat-card { background:var(--card); border-radius:var(--r); margin-bottom:0;
  overflow:hidden; border:3px solid transparent; transition:border-color .2s; }
.mat-card.selected { border-color:#000; }
.mat-head { display:flex; gap:10px; align-items:flex-start; padding:12px; cursor:pointer; }
.mat-thumb { width:64px; height:64px; background:#bbb; border-radius:8px; flex-shrink:0;
  display:flex; align-items:center; justify-content:center; font-size:22px; }
.mat-hi { flex:1; }
.mat-name { font-size:14px; font-weight:700; margin-bottom:3px; }
.mat-short { font-size:12px; font-weight:300; color:#666; line-height:1.4; }
.mat-exp { width:28px; height:28px; background:#0001; border:none; border-radius:50%;
  display:flex; align-items:center; justify-content:center; cursor:pointer;
  font-size:14px; color:#555; transition:transform .25s; flex-shrink:0; margin-top:2px; }
.mat-card.open .mat-exp { transform:rotate(180deg); }
.mat-body { max-height:0; overflow:hidden; transition:max-height .3s; padding:0 12px; }
.mat-card.open .mat-body { max-height:400px; }
.mat-bi { padding-bottom:12px; border-top:1px solid rgba(0,0,0,.08); padding-top:10px; }
.mat-det { font-size:13px; font-weight:300; color:#444; line-height:1.6; margin-bottom:10px; }
.mat-acts { display:flex; gap:8px; }
.btn-smp { width:100%; height:36px; background:#000; color:#fff; border:none; border-radius:8px;
  font-size:13px; font-weight:700; cursor:pointer; }

/* –ò–¢–û–ì */
.sum-row { display:flex; justify-content:space-between; padding:10px 0;
  border-bottom:1px solid #eee; font-size:14px; }
.sum-row:last-child { border-bottom:none; }
.sum-k { font-weight:300; color:#666; }
.sum-v { font-weight:700; text-align:right; max-width:60%; }

/* –ó–∞–≥–ª—É—à–∫–∞ –∫–∞—Ç–∞–ª–æ–≥–∞ */
.cat-placeholder { text-align:center; padding:40px 20px; color:#aaa; }
.cat-placeholder .cp-icon { font-size:48px; margin-bottom:12px; }
.cat-placeholder .cp-text { font-size:15px; font-weight:300; line-height:1.5; }
</style>
</head>
<body>
<div class="app">
  <div class="prog-wrap">
    <div class="prog-lbl" id="plbl">–®–∞–≥ 1 –∏–∑ 10</div>
    <div class="prog-bar"><div class="prog-fill" id="pfill" style="width:10%"></div></div>
  </div>

  <!-- 1: –¢–∏–ø –¥–æ–º–∞ -->
  <div class="screen active" id="screen-1">
    <div class="sh"><div class="st">–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –¥–æ–º–∞:</div></div>
    <div class="sb">
      <div class="house-cards">
        <div class="house-card" onclick="selHouse(this,'–û–¥–Ω–æ—ç—Ç–∞–∂–Ω—ã–π –¥–æ–º')">
          <div class="hcp"><div class="ic">üè†</div>–ö–∞—Ä—Ç–∏–Ω–∫–∞ —Å –¥–æ–º–æ–º, –æ–ø–∏—Å–∞–Ω–∏–µ</div>
          <div class="hcl">–û–¥–Ω–æ—ç—Ç–∞–∂–Ω—ã–π –¥–æ–º</div>
        </div>
        <div class="house-card" onclick="selHouse(this,'–î–≤—É—Ö—ç—Ç–∞–∂–Ω—ã–π –¥–æ–º')">
          <div class="hcp"><div class="ic">üè°</div>–ö–∞—Ä—Ç–∏–Ω–∫–∞ —Å –¥–æ–º–æ–º, –æ–ø–∏—Å–∞–Ω–∏–µ</div>
          <div class="hcl">–î–≤—É—Ö—ç—Ç–∞–∂–Ω—ã–π –¥–æ–º</div>
        </div>
        <div class="house-card" onclick="selHouse(this,'–î–æ–º —Å –º–∞–Ω—Å–∞—Ä–¥–æ–π')">
          <div class="hcp"><div class="ic">üèò</div>–ö–∞—Ä—Ç–∏–Ω–∫–∞ —Å –¥–æ–º–æ–º, –æ–ø–∏—Å–∞–Ω–∏–µ</div>
          <div class="hcl">–î–æ–º —Å –º–∞–Ω—Å–∞—Ä–¥–æ–π</div>
        </div>
        <!-- –ù–û–í–û–ï: –£—á–∞—Å—Ç–æ–∫ –±–µ–∑ –¥–æ–º–∞ -->
        <div class="house-card" onclick="selHouse(this,'–£—á–∞—Å—Ç–æ–∫ –±–µ–∑ –¥–æ–º–∞')">
          <div class="hcp"><div class="ic">üåø</div>–ü—É—Å—Ç–æ–π —É—á–∞—Å—Ç–æ–∫, –±–µ–∑ —Å—Ç—Ä–æ–µ–Ω–∏–π</div>
          <div class="hcl">–£—á–∞—Å—Ç–æ–∫ –±–µ–∑ –¥–æ–º–∞</div>
        </div>
        <label class="upload-card">
          <input type="file" id="upload-input" accept="image/*">
          <span>üì∑</span><span>–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–æ—Ç–æ –¥–æ–º–∞ –∏–ª–∏ —É—á–∞—Å—Ç–∫–∞</span>
        </label>
      </div>
    </div>
    <button class="btn-full" onclick="goTo(2)">–î–ê–õ–¨–®–ï <span>‚Üí</span></button>
  </div>

  <!-- 2: –ü–ª–æ—â–∞–¥—å -->
  <div class="screen" id="screen-2">
    <div class="sh"><div class="st">–ó–∞–¥–∞–π—Ç–µ –æ–±—â—É—é –ø–ª–æ—â–∞–¥—å –¥–æ–º–∞:</div></div>
    <div class="sb">
      <div class="view3d-slot" id="slot-2"></div>
      <div class="p-row"><div class="p-lbl">–û–±—â–∞—è –ø–ª–æ—â–∞–¥—å (–∫–≤.–º):</div>
        <input class="p-inp" type="number" id="v-area" value="120" min="20" max="1000" oninput="onParamChange()"></div>
    </div>
    <div class="nav-row">
      <button class="btn-back" onclick="goTo(1)">‚Üê</button>
      <button class="btn-next" onclick="goTo(3)">–î–ê–õ–¨–®–ï <span>‚Üí</span></button>
    </div>
  </div>

  <!-- 3: –í—ã—Å–æ—Ç–∞ —ç—Ç–∞–∂–∞ -->
  <div class="screen" id="screen-3">
    <div class="sh"><div class="st">–ó–∞–¥–∞–π—Ç–µ –≤—ã—Å–æ—Ç—É —ç—Ç–∞–∂–∞:</div></div>
    <div class="sb">
      <div class="view3d-slot" id="slot-3"></div>
      <div class="p-row"><div class="p-lbl">–í—ã—Å–æ—Ç–∞ —ç—Ç–∞–∂–∞ (—Å–º):</div>
        <input class="p-inp" type="number" id="v-floor" value="400" min="240" max="600" oninput="onParamChange()"></div>
    </div>
    <div class="nav-row">
      <button class="btn-back" onclick="goTo(2)">‚Üê</button>
      <button class="btn-next" onclick="goTo(4)">–î–ê–õ–¨–®–ï <span>‚Üí</span></button>
    </div>
  </div>

  <!-- 4: –§—É–Ω–¥–∞–º–µ–Ω—Ç -->
  <div class="screen" id="screen-4">
    <div class="sh"><div class="st">–ó–∞–¥–∞–π—Ç–µ –≤—ã—Å–æ—Ç—É —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞:</div></div>
    <div class="sb">
      <div class="view3d-slot" id="slot-4"></div>
      <div class="p-row"><div class="p-lbl">–§—É–Ω–¥–∞–º–µ–Ω—Ç (—Å–º):</div>
        <input class="p-inp" type="number" id="v-found" value="80" min="0" max="300" oninput="onParamChange()"></div>
    </div>
    <div class="nav-row">
      <button class="btn-back" onclick="goTo(3)">‚Üê</button>
      <button class="btn-next" onclick="goTo(5)">–î–ê–õ–¨–®–ï <span>‚Üí</span></button>
    </div>
  </div>

  <!-- 5: –ß—Ç–æ –ø–ª–∞–Ω–∏—Ä—É–µ—Ç–µ -->
  <div class="screen" id="screen-5">
    <div class="sh">
      <div class="st">–ß—Ç–æ –ø–ª–∞–Ω–∏—Ä—É–µ—Ç–µ —Å—Ç—Ä–æ–∏—Ç—å –∏–ª–∏ —É–ª—É—á—à–∞—Ç—å:</div>
      <div class="ss">(–≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω—É –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–∑–∏—Ü–∏–π)</div>
    </div>
    <div class="sb">
      <div class="checklist">
        <div class="ci" onclick="tci(this)" data-id="terrace"><span class="ci-text">–¢–µ—Ä—Ä–∞—Å–∞</span><div class="cb"></div></div>
        <div class="ci" onclick="tci(this)" data-id="porch"><span class="ci-text">–ö—Ä—ã–ª—å—Ü–æ</span><div class="cb"></div></div>
        <div class="ci" onclick="tci(this)" data-id="paths"><span class="ci-text">–î–æ—Ä–æ–∂–∫–∏</span><div class="cb"></div></div>
        <div class="ci" onclick="tci(this)" data-id="fence"><span class="ci-text">–ó–∞–±–æ—Ä –≤–æ–∫—Ä—É–≥ —É—á–∞—Å—Ç–∫–∞</span><div class="cb"></div></div>
        <div class="ci" onclick="tci(this)" data-id="facade"><span class="ci-text">–û—Ç–¥–µ–ª–∫–∞ —Ñ–∞—Å–∞–¥–∞</span><div class="cb"></div></div>
        <div class="ci" onclick="tci(this)" data-id="beds"><span class="ci-text">–ì—Ä—è–¥–∫–∏</span><div class="cb"></div></div>
        <div class="ci" onclick="tci(this)" data-id="furniture"><span class="ci-text">–°–∞–¥–æ–≤–∞—è –º–µ–±–µ–ª—å</span><div class="cb"></div></div>
        <div class="ci" onclick="tci(this)" data-id="pool_terrace"><span class="ci-text">–¢–µ—Ä—Ä–∞—Å–∞ —É –±–∞—Å—Å–µ–π–Ω–∞</span><div class="cb"></div></div>
        <div class="ci" onclick="tci(this)" data-id="pier"><span class="ci-text">–ü—Ä–∏—á–∞–ª</span><div class="cb"></div></div>
      </div>
    </div>
    <div class="nav-row">
      <button class="btn-back" onclick="goTo(4)">‚Üê</button>
      <button class="btn-next" onclick="goToConditional()">–î–ê–õ–¨–®–ï <span>‚Üí</span></button>
    </div>
  </div>

  <!-- 6: –¢–µ—Ä—Ä–∞—Å–∞ ‚Äî —Ç–æ—á–∫–∏ -->
  <div class="screen" id="screen-6">
    <div class="sh"><div class="st" id="s6-title">–ü–æ—Å—Ç–∞–≤—å—Ç–µ —Ç–æ—á–∫–∏ –≤ —É–≥–ª–∞—Ö —Ç–µ—Ä—Ä–∞—Å—ã:</div></div>
    <div class="sb">
      <p class="cv-hint">–¢–æ—á–∫–∏ –ø—Ä–∏–ª–∏–ø–∞—é—Ç –∫ —Å–µ—Ç–∫–µ. –©–∏–ø–æ–∫ ‚Äî –º–∞—Å—à—Ç–∞–±, —Ç—è–Ω–∏—Ç–µ ‚Äî –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ</p>
      <div class="cv-wrap" id="cw-terrace"><canvas id="cv-terrace"></canvas></div>
      <div class="cv-acts">
        <button class="btn-u" onclick="undoPt('terrace')">‚Ü© –û—Ç–º–µ–Ω–∏—Ç—å</button>
        <button class="btn-c" onclick="clrPts('terrace')">‚úï –û—á–∏—Å—Ç–∏—Ç—å</button>
      </div>
      <div class="tg" onclick="ttg(this)" data-id="terrace-railing"><span class="tg-txt">–ù—É–∂–Ω–æ –æ–≥—Ä–∞–∂–¥–µ–Ω–∏–µ</span><div class="tg-ind"></div></div>
      <div class="tg" onclick="ttg(this)" data-id="terrace-roof"><span class="tg-txt">–ù—É–∂–µ–Ω –Ω–∞–≤–µ—Å</span><div class="tg-ind"></div></div>
    </div>
    <div class="nav-row">
      <button class="btn-back" onclick="goTo(5)">‚Üê</button>
      <button class="btn-next" onclick="goToAfter6()">–î–ê–õ–¨–®–ï <span>‚Üí</span></button>
    </div>
  </div>

  <!-- 6b: –¢–µ—Ä—Ä–∞—Å–∞ —É –±–∞—Å—Å–µ–π–Ω–∞ ‚Äî —Ç–æ—á–∫–∏ -->
  <div class="screen" id="screen-6b">
    <div class="sh"><div class="st">–ü–æ—Å—Ç–∞–≤—å—Ç–µ —Ç–æ—á–∫–∏ —Ç–µ—Ä—Ä–∞—Å—ã —É –±–∞—Å—Å–µ–π–Ω–∞:</div></div>
    <div class="sb">
      <p class="cv-hint">–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –ø–ª–∞–Ω —á—Ç–æ–±—ã –æ—Ç–º–µ—Ç–∏—Ç—å —É–≥–ª—ã</p>
      <div class="cv-wrap" id="cw-pool_terrace"><canvas id="cv-pool_terrace"></canvas></div>
      <div class="cv-acts">
        <button class="btn-u" onclick="undoPt('pool_terrace')">‚Ü© –û—Ç–º–µ–Ω–∏—Ç—å</button>
        <button class="btn-c" onclick="clrPts('pool_terrace')">‚úï –û—á–∏—Å—Ç–∏—Ç—å</button>
      </div>
      <div class="tg" onclick="ttg(this)"><span class="tg-txt">–ù—É–∂–Ω–æ –æ–≥—Ä–∞–∂–¥–µ–Ω–∏–µ –±–∞—Å—Å–µ–π–Ω–∞</span><div class="tg-ind"></div></div>
    </div>
    <div class="nav-row">
      <button class="btn-back" onclick="goToPrev('pool_terrace')">‚Üê</button>
      <button class="btn-next" onclick="goToAfter('pool_terrace')">–î–ê–õ–¨–®–ï <span>‚Üí</span></button>
    </div>
  </div>

  <!-- 6c: –î–æ—Ä–æ–∂–∫–∏ ‚Äî —Ç–æ—á–∫–∏ -->
  <div class="screen" id="screen-6c">
    <div class="sh"><div class="st">–û–±–æ–∑–Ω–∞—á—å—Ç–µ –¥–æ—Ä–æ–∂–∫–∏ –Ω–∞ –ø–ª–∞–Ω–µ:</div></div>
    <div class="sb">
      <p class="cv-hint">–ù–∞–∂–∏–º–∞–π—Ç–µ —Ç–æ—á–∫–∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –≤–¥–æ–ª—å –¥–æ—Ä–æ–∂–∫–∏</p>
      <div class="cv-wrap" id="cw-paths"><canvas id="cv-paths"></canvas></div>
      <div class="cv-acts">
        <button class="btn-u" onclick="undoPt('paths')">‚Ü© –û—Ç–º–µ–Ω–∏—Ç—å</button>
        <button class="btn-c" onclick="clrPts('paths')">‚úï –û—á–∏—Å—Ç–∏—Ç—å</button>
      </div>
      <div class="p-row" style="margin-top:4px;">
        <div class="p-lbl">–®–∏—Ä–∏–Ω–∞ –¥–æ—Ä–æ–∂–∫–∏ (—Å–º):</div>
        <input class="p-inp" type="number" id="v-paths-width" value="120" min="60" max="300">
      </div>
    </div>
    <div class="nav-row">
      <button class="btn-back" onclick="goToPrev('paths')">‚Üê</button>
      <button class="btn-next" onclick="goToAfter('paths')">–î–ê–õ–¨–®–ï <span>‚Üí</span></button>
    </div>
  </div>

  <!-- 6d: –ü—Ä–∏—á–∞–ª ‚Äî —Ç–æ—á–∫–∏ -->
  <div class="screen" id="screen-6d">
    <div class="sh"><div class="st">–ü–æ—Å—Ç–∞–≤—å—Ç–µ —Ç–æ—á–∫–∏ –≤ —É–≥–ª–∞—Ö –ø—Ä–∏—á–∞–ª–∞:</div></div>
    <div class="sb">
      <p class="cv-hint">–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –ø–ª–∞–Ω —É—á–∞—Å—Ç–∫–∞ —á—Ç–æ–±—ã –æ—Ç–º–µ—Ç–∏—Ç—å —Ñ–æ—Ä–º—É –ø—Ä–∏—á–∞–ª–∞</p>
      <div class="cv-wrap" id="cw-pier"><canvas id="cv-pier"></canvas></div>
      <div class="cv-acts">
        <button class="btn-u" onclick="undoPt('pier')">‚Ü© –û—Ç–º–µ–Ω–∏—Ç—å</button>
        <button class="btn-c" onclick="clrPts('pier')">‚úï –û—á–∏—Å—Ç–∏—Ç—å</button>
      </div>
      <div class="tg" onclick="ttg(this)"><span class="tg-txt">–ù—É–∂–Ω—ã –ø–µ—Ä–∏–ª–∞ –ø—Ä–∏—á–∞–ª–∞</span><div class="tg-ind"></div></div>
      <div class="tg" onclick="ttg(this)"><span class="tg-txt">–ù—É–∂–Ω–∞ –∫—Ä—ã—à–∞ / –Ω–∞–≤–µ—Å</span><div class="tg-ind"></div></div>
    </div>
    <div class="nav-row">
      <button class="btn-back" onclick="goToPrev('pier')">‚Üê</button>
      <button class="btn-next" onclick="goToAfter('pier')">–î–ê–õ–¨–®–ï <span>‚Üí</span></button>
    </div>
  </div>

  <!-- 7: –ö—Ä—ã–ª—å—Ü–æ ‚Äî drag+resize -->
  <div class="screen" id="screen-7">
    <div class="sh"><div class="st">–£–∫–∞–∂–∏—Ç–µ –º–µ—Å—Ç–æ –∏ —Ä–∞–∑–º–µ—Ä –∫—Ä—ã–ª—å—Ü–∞</div></div>
    <div class="sb">
      <p class="cv-hint">–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∫—Ä—ã–ª—å—Ü–æ, –ø–æ—Ç—è–Ω–∏—Ç–µ –∑–∞ —É–≥–æ–ª —á—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å —Ä–∞–∑–º–µ—Ä</p>
      <div class="cv-wrap" id="cw-porch" style="cursor:default;"><canvas id="cv-porch"></canvas></div>
      <div class="tg" onclick="ttg(this)"><span class="tg-txt">–ù—É–∂–Ω—ã –ø–µ—Ä–∏–ª–∞</span><div class="tg-ind"></div></div>
    </div>
    <div class="nav-row">
      <button class="btn-back" onclick="goToPrev('porch')">‚Üê</button>
      <button class="btn-next" onclick="goToAfter('porch')">–î–ê–õ–¨–®–ï <span>‚Üí</span></button>
    </div>
  </div>

  <!-- 8: –ó–∞–±–æ—Ä ‚Äî —Ç–æ—á–∫–∏ -->
  <div class="screen" id="screen-8">
    <div class="sh"><div class="st">–ü–æ—Å—Ç–∞–≤—å—Ç–µ —Ç–æ—á–∫–∏ –≤ —É–≥–ª–∞—Ö –∑–∞–±–æ—Ä–∞</div></div>
    <div class="sb">
      <p class="cv-hint">–¢–æ—á–∫–∏ –ø—Ä–∏–ª–∏–ø–∞—é—Ç –∫ —Å–µ—Ç–∫–µ (1 –∫–ª–µ—Ç–∫–∞ = 1 –º). –©–∏–ø–æ–∫ ‚Äî –º–∞—Å—à—Ç–∞–±</p>
      <div class="cv-wrap" id="cw-fence"><canvas id="cv-fence"></canvas></div>
      <div class="cv-acts">
        <button class="btn-u" onclick="undoPt('fence')">‚Ü© –û—Ç–º–µ–Ω–∏—Ç—å</button>
        <button class="btn-c" onclick="clrPts('fence')">‚úï –û—á–∏—Å—Ç–∏—Ç—å</button>
      </div>
    </div>
    <div class="nav-row">
      <button class="btn-back" onclick="goToPrev('fence')">‚Üê</button>
      <button class="btn-next" onclick="goToAfter('fence')">–î–ê–õ–¨–®–ï <span>‚Üí</span></button>
    </div>
  </div>

  <!-- 10: –ú–∞—Ç–µ—Ä–∏–∞–ª—ã -->
  <div class="screen" id="screen-10">
    <div class="sh">
      <div class="st" id="sec-title">–¢–µ—Ä—Ä–∞—Å–∞</div>
      <div class="ss">(—Ä–∞–∑–¥–µ–ª—ã –º–æ–∂–Ω–æ –ª–∏—Å—Ç–∞—Ç—å)</div>
    </div>
    <div class="sb">
      <div class="sec-nav" id="sec-nav"></div>
      <div class="view3d-slot" id="three-container" style="cursor:grab; touch-action:none;">
        <div id="three-hint" style="position:absolute;bottom:6px;left:0;right:0;text-align:center;
             font-size:10px;color:rgba(255,255,255,0.6);pointer-events:none;letter-spacing:.03em;z-index:1;">
          ‚òùÔ∏è –≤—Ä–∞—â–µ–Ω–∏–µ ¬∑ —â–∏–ø–æ–∫ ‚Äî –∑—É–º
        </div>
      </div>
      <div class="sample-lbl" id="sample-lbl">–û–±—Ä–∞–∑—Ü—ã:</div>
      <div class="samples-grid" id="samples-grid"></div>
    </div>
    <div class="nav-row">
      <button class="btn-back" onclick="goBack10()">‚Üê</button>
      <button class="btn-next" onclick="openCatalog()">–ö–ê–¢–ê–õ–û–ì <span>‚Ä∫</span></button>
      <button class="btn-icon" onclick="showSummary()">‚úì</button>
    </div>
  </div>

  <!-- –ö–∞—Ç–∞–ª–æ–≥: –¢–û–õ–¨–ö–û —Ç–µ—Ä—Ä–∞—Å–Ω–∞—è –¥–æ—Å–∫–∞ —Å —Ñ–∏–ª—å—Ç—Ä–∞–º–∏ -->
  <div class="screen" id="screen-catalog">
    <div class="sh"><div class="st" id="cat-title">–¢–µ—Ä—Ä–∞—Å–Ω–∞—è –¥–æ—Å–∫–∞</div></div>
    <div class="sb" id="cat-body">
      <!-- –†–µ–Ω–¥–µ—Ä–∏—Ç—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏: –ª–∏–±–æ —Ñ–∏–ª—å—Ç—Ä—ã, –ª–∏–±–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã -->
    </div>
    <div class="nav-row" id="cat-nav">
      <button class="btn-back" id="cat-back-btn" onclick="goTo(10)">‚Üê</button>
      <button class="btn-next" id="cat-action-btn" onclick="showCatalogResults()">–ü–û–î–û–ë–†–ê–¢–¨ <span>‚Üí</span></button>
    </div>
  </div>

  <!-- –ò—Ç–æ–≥ -->
  <div class="screen" id="screen-summary">
    <div class="sh"><div class="st">–í–∞—à –ø—Ä–æ–µ–∫—Ç:</div></div>
    <div class="sb"><div id="sum-body"></div></div>
    <button class="btn-full" onclick="alert('–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞! üéâ')">–û–¢–ü–†–ê–í–ò–¢–¨ –ó–ê–Ø–í–ö–£ <span>‚Üí</span></button>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// –î–ê–ù–ù–´–ï
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const SECS = [
  {id:'terrace',      lbl:'–¢–µ—Ä—Ä–∞—Å–∞',           req:'terrace'},
  {id:'porch',        lbl:'–ö—Ä—ã–ª—å—Ü–æ',            req:'porch'},
  {id:'paths',        lbl:'–î–æ—Ä–æ–∂–∫–∏',            req:'paths'},
  {id:'fence',        lbl:'–ó–∞–±–æ—Ä',              req:'fence'},
  {id:'facade',       lbl:'–§–∞—Å–∞–¥',              req:'facade'},
  {id:'beds',         lbl:'–ì—Ä—è–¥–∫–∏',             req:'beds'},
  {id:'furniture',    lbl:'–ú–µ–±–µ–ª—å',             req:'furniture'},
  {id:'pool_terrace', lbl:'–¢–µ—Ä—Ä–∞—Å–∞ —É –±–∞—Å—Å–µ–π–Ω–∞', req:'pool_terrace'},
  {id:'pier',         lbl:'–ü—Ä–∏—á–∞–ª',             req:'pier'},
];

// –ü–æ—Ä—è–¥–æ–∫ —à–∞–≥–æ–≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ (–¥–æ —à–∞–≥–∞ 10)
// –ö–ª—é—á ‚Äî id —Å–µ–∫—Ü–∏–∏, –∑–Ω–∞—á–µ–Ω–∏–µ ‚Äî id —ç–∫—Ä–∞–Ω–∞
const SEC_SCREEN = {
  terrace:      '6',
  pool_terrace: '6b',
  paths:        '6c',
  pier:         '6d',
  porch:        '7',
  fence:        '8',
  // facade —É–±—Ä–∞–Ω ‚Äî —Å—Ä–∞–∑—É –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –∫ —à–∞–≥—É 10
};

// 16 —Ü–≤–µ—Ç–æ–≤ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞
const CATALOG_COLORS = [
  {id:'c1',  hex:'#5C3317', label:'–¢—ë–º–Ω—ã–π –¥—É–±'},
  {id:'c2',  hex:'#8B6331', label:'–°–≤–µ—Ç–ª—ã–π –¥—É–±'},
  {id:'c3',  hex:'#C8A96E', label:'–ù–∞—Ç—É—Ä–∞–ª—å–Ω—ã–π'},
  {id:'c4',  hex:'#F5DEB3', label:'–ü—à–µ–Ω–∏—á–Ω—ã–π'},
  {id:'c5',  hex:'#E8D5B0', label:'–°–æ—Å–Ω–∞'},
  {id:'c6',  hex:'#D2B48C', label:'–ë–µ–∂–µ–≤—ã–π'},
  {id:'c7',  hex:'#A0522D', label:'–¢–µ—Ä—Ä–∞–∫–æ—Ç'},
  {id:'c8',  hex:'#704214', label:'–®–æ–∫–æ–ª–∞–¥'},
  {id:'c9',  hex:'#3D2B1F', label:'–í–µ–Ω–≥–µ'},
  {id:'c10', hex:'#1C1C1C', label:'–ê–Ω—Ç—Ä–∞—Ü–∏—Ç'},
  {id:'c11', hex:'#808080', label:'–°–µ—Ä—ã–π'},
  {id:'c12', hex:'#B0C4B1', label:'–ó–µ–ª—ë–Ω—ã–π'},
  {id:'c13', hex:'#E0E0E0', label:'–°–≤–µ—Ç–ª–æ-—Å–µ—Ä—ã–π'},
  {id:'c14', hex:'#F5F5F5', label:'–ë–µ–ª—ã–π'},
  {id:'c15', hex:'#C0A080', label:'–¢–∞—É–ø'},
  {id:'c16', hex:'#9B7653', label:'–û—Ä–µ—Ö'},
];

const PRICE_TIERS = [
  {id:'budget',    lbl:'–ë—é–¥–∂–µ—Ç–Ω–æ',             sub:'–¥–æ 2 000 ‚ÇΩ/–º¬≤'},
  {id:'balanced',  lbl:'–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–æ',        sub:'2 000 ‚Äì 5 000 ‚ÇΩ/–º¬≤'},
  {id:'premium',   lbl:'–ü—Ä–µ–º–∏–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ',  sub:'–æ—Ç 5 000 ‚ÇΩ/–º¬≤'},
  {id:'mpk',       lbl:'–î–æ—Å–∫–∞ –∏–∑ –ú–ü–ö',          sub:'–æ—Ç 10 000 ‚ÇΩ/–º¬≤'},
];

// –ü–æ–∑–∏—Ü–∏–∏ –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞ outdoor-mebel.ru ‚Äî –î–æ—Å–∫–∞ –î–ü–ö —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è
const STUB_RESULTS = [
  {
    id:1, ic:'üü´',
    name:'TalverWood –°—Ç–∞–Ω–¥–∞—Ä—Ç 150√ó25',
    short:'–î–ü–ö, –¥–≤—É—Å—Ç–æ—Ä–æ–Ω–Ω—è—è, –≤–µ–ª—å–≤–µ—Ç/–≥–ª–∞–¥–∫–∞—è, 5 —Ü–≤–µ—Ç–æ–≤',
    detail:'–î–æ—Å–∫–∞ –î–ü–ö –±—Ä–µ–Ω–¥–∞ TalverWood. –°–æ—Å—Ç–∞–≤: 60% –¥—Ä–µ–≤–µ—Å–Ω–∞—è –º—É–∫–∞, 40% –ø–æ–ª–∏–º–µ—Ä. –†–∞–∑–º–µ—Ä: 150√ó25√ó4000 –º–º. –ü–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å —Å –¥–≤—É—Ö —Å—Ç–æ—Ä–æ–Ω: –≤–µ–ª—å–≤–µ—Ç + –≥–ª–∞–¥–∫–∞—è. –¶–≤–µ—Ç–∞: —Ç–∏–∫, –≤–µ–Ω–≥–µ, —Å–µ—Ä—ã–π, –∫–æ—Ñ–µ, –±–µ–ª—ã–π. –ì–∞—Ä–∞–Ω—Ç–∏—è 10 –ª–µ—Ç.',
    price:'–æ—Ç 1 850 ‚ÇΩ/–º¬≤',
    color:'#8B6331',
    url:'https://outdoor-mebel.ru/catalog/terrasnaya_doska_iz_dpk/doska_dpk_universalnaya/talverwood',
  },
  {
    id:2, ic:'üü§',
    name:'AIWOODek Premium 140√ó22',
    short:'–î–ü–ö, –ø–æ–ª–Ω–æ—Ç–µ–ª–∞—è, —Å–∫—Ä—ã—Ç—ã–π –∫—Ä–µ–ø—ë–∂, 8 —Ü–≤–µ—Ç–æ–≤',
    detail:'–¢–µ—Ä—Ä–∞—Å–Ω–∞—è –¥–æ—Å–∫–∞ AIWOODek Premium. –ü–æ–ª–Ω–æ—Ç–µ–ª—ã–π –ø—Ä–æ—Ñ–∏–ª—å ‚Äî –ø–æ–≤—ã—à–µ–Ω–Ω–∞—è –∂—ë—Å—Ç–∫–æ—Å—Ç—å. –†–∞–∑–º–µ—Ä: 140√ó22√ó4000 –º–º. –°–∏—Å—Ç–µ–º–∞ —Å–∫—Ä—ã—Ç–æ–≥–æ –∫—Ä–µ–ø–µ–∂–∞ –≤ –∫–æ–º–ø–ª–µ–∫—Ç–µ. –§–∞–∫—Ç—É—Ä–∞: –Ω–∞—Ç—É—Ä–∞–ª—å–Ω–æ–µ –¥–µ—Ä–µ–≤–æ. –¶–≤–µ—Ç–∞: 8 –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –æ—Ç —Å–≤–µ—Ç–ª–æ–≥–æ –¥—É–±–∞ –¥–æ –∞–Ω—Ç—Ä–∞—Ü–∏—Ç–∞.',
    price:'–æ—Ç 2 400 ‚ÇΩ/–º¬≤',
    color:'#704214',
    url:'https://outdoor-mebel.ru/catalog/terrasnaya_doska_iz_dpk/doska_dpk_universalnaya/terrasnaya_doska_aiwood',
  },
  {
    id:3, ic:'ü™µ',
    name:'NauticPrime Prestige 163√ó23',
    short:'–î–ü–ö, —à–∏—Ä–æ–∫–∞—è, –∫–æ—ç–∫—Å—Ç—Ä—É–∑–∏—è, –º–æ—Ä–æ–∑–æ—Å—Ç–æ–π–∫–∞—è',
    detail:'–î–æ—Å–∫–∞ NauticPrime —Å–µ—Ä–∏–∏ Prestige. –¢–µ—Ö–Ω–æ–ª–æ–≥–∏—è –∫–æ—ç–∫—Å—Ç—Ä—É–∑–∏–∏ ‚Äî –∑–∞—â–∏—Ç–Ω—ã–π –ø–æ–ª–∏–º–µ—Ä–Ω—ã–π —Å–ª–æ–π —Å–Ω–∞—Ä—É–∂–∏. –®–∏—Ä–∏–Ω–∞ 163 –º–º ‚Äî –º–µ–Ω—å—à–µ —Å—Ç—ã–∫–æ–≤. –£—Å—Ç–æ–π—á–∏–≤–∞ –∫ –º–æ—Ä–æ–∑—É –¥–æ ‚àí50¬∞C –∏ –£–§-–∏–∑–ª—É—á–µ–Ω–∏—é. –ù–µ —Ç—Ä–µ–±—É–µ—Ç –ø–æ–∫—Ä–∞—Å–∫–∏ –≤–µ—Å—å —Å—Ä–æ–∫ —Å–ª—É–∂–±—ã (25 –ª–µ—Ç).',
    price:'–æ—Ç 3 700 ‚ÇΩ/–º¬≤',
    color:'#5C3317',
    url:'https://outdoor-mebel.ru/catalog/terrasnaya_doska_iz_dpk/doska_dpk_universalnaya/nauticprime',
  },
  {
    id:4, ic:'‚¨ú',
    name:'POLIVAN Eco Line 120√ó28',
    short:'–î–ü–ö, –ª—ë–≥–∫–∞—è –ø–æ–ª–∞—è, –±—é–¥–∂–µ—Ç–Ω—ã–π —Å–µ–≥–º–µ–Ω—Ç',
    detail:'–î–æ—Å–∫–∞ POLIVAN —Å–µ—Ä–∏–∏ Eco Line. –ü–æ–ª—ã–π –ø—Ä–æ—Ñ–∏–ª—å ‚Äî —Å–Ω–∏–∂–∞–µ—Ç –≤–µ—Å –∏ —Å—Ç–æ–∏–º–æ—Å—Ç—å –Ω–∞—Å—Ç–∏–ª–∞. –†–∞–∑–º–µ—Ä: 120√ó28√ó3000 –º–º. –ü—Ä–æ—Å—Ç–æ–π –º–æ–Ω—Ç–∞–∂ –Ω–∞ –ª–∞–≥–∏ —Å —à–∞–≥–æ–º 300‚Äì400 –º–º. –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –≤—ã–±–æ—Ä –¥–ª—è –¥–∞—á–Ω—ã—Ö —Ç–µ—Ä—Ä–∞—Å –∏ –±–µ—Å–µ–¥–æ–∫.',
    price:'–æ—Ç 1 350 ‚ÇΩ/–º¬≤',
    color:'#D2B48C',
    url:'https://outdoor-mebel.ru/catalog/terrasnaya_doska_iz_dpk/doska_dpk_universalnaya/polivan',
  },
];

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// –°–û–°–¢–û–Ø–ù–ò–ï
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const S = {
  houseType: null,
  sections: [],
  pts: { terrace:[], pool_terrace:[], paths:[], pier:[], fence:[] },
  porch: { x:0.3, y:0.3, w:0.2, h:0.12 },
  mats: {},
  samples: [],    // [{id, name, color}] ‚Äî –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–µ –æ–±—Ä–∞–∑—Ü—ã
  activeSample: null, // {id, name, color} ‚Äî —Ç–µ–∫—É—â–∏–π –≤—ã–±—Ä–∞–Ω–Ω—ã–π –¥–ª—è –ø—Ä–∏–º–µ—Ä–∫–∏
  curSec: 0,
  catColors: new Set(),
  catPrice: null,
  catShowResults: false,
};
const TOTAL = 10;
let step = 1;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// –ù–ê–í–ò–ì–ê–¶–ò–Ø
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function goTo(s) {
  const prev = document.getElementById('screen-' + step);
  if (prev) prev.classList.remove('active');
  step = s;
  const el = document.getElementById('screen-' + s);
  if (el) el.classList.add('active');
  updProg();
  window.scrollTo(0, 0);
  const cvMap = {
    '2':  ()=>init3dCanvas('slot-2'),
    '3':  ()=>init3dCanvas('slot-3'),
    '4':  ()=>init3dCanvas('slot-4'),
    '6':  ()=>initSnapCanvas('terrace'),
    '6b': ()=>initSnapCanvas('pool_terrace'),
    '6c': ()=>initPathsCanvas(),
    '6d': ()=>initSnapCanvas('pier'),
    '7':  ()=>initPorchCanvas(),
    '8':  ()=>initSnapCanvas('fence'),
    '10': ()=>{ init3dCanvas('three-container'); renderSec(); },
  };
  if (cvMap[String(s)]) setTimeout(cvMap[String(s)], 80);
}

function updProg() {
  const numericSteps = {'6b':6,'6c':6,'6d':6};
  const n = typeof step === 'number' ? step : (numericSteps[step] || TOTAL);
  document.getElementById('pfill').style.width = Math.round(n/TOTAL*100)+'%';
  document.getElementById('plbl').textContent = '–®–∞–≥ '+n+' –∏–∑ '+TOTAL;
}

// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö —à–∞–≥–æ–≤-—ç–∫—Ä–∞–Ω–æ–≤ (id —Å–µ–∫—Ü–∏–π –∏–º–µ—é—â–∏—Ö —ç–∫—Ä–∞–Ω)
function getStepOrder() {
  const order = ['terrace','porch','paths','fence','pool_terrace','pier'];
  return order.filter(id => S.sections.includes(id));
}

function goToConditional() {
  S.sections = [...document.querySelectorAll('.ci.checked')].map(e => e.dataset.id);
  const first = getStepOrder()[0];
  if (first) goTo(SEC_SCREEN[first]);
  else goTo(10);
}

// –ü–µ—Ä–µ—Ö–æ–¥ –í–ü–ï–†–Å–î –ø–æ—Å–ª–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —Å–µ–∫—Ü–∏–∏
function goToAfter(secId) {
  const order = getStepOrder();
  const idx = order.indexOf(secId);
  const next = order[idx + 1];
  if (next) goTo(SEC_SCREEN[next]);
  else goTo(10);
}

// –ü–µ—Ä–µ—Ö–æ–¥ –≤–ø–µ—Ä—ë–¥ —Å–æ —à–∞–≥–∞ 6 (—Ç–µ—Ä—Ä–∞—Å–∞)
function goToAfter6() {
  // –ö—Ä—ã–ª—å—Ü–æ: –µ—Å–ª–∏ –µ—Å—Ç—å —Ç–µ—Ä—Ä–∞—Å–∞, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–ª–∞–Ω —Å —Ç–µ—Ä—Ä–∞—Å–æ–π
  goToAfter('terrace');
}

// –ü–µ—Ä–µ—Ö–æ–¥ –ù–ê–ó–ê–î —Å–æ —Å—Ç–æ—Ä–æ–Ω—ã –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —Å–µ–∫—Ü–∏–∏
function goToPrev(secId) {
  const order = getStepOrder();
  const idx = order.indexOf(secId);
  if (idx > 0) goTo(SEC_SCREEN[order[idx - 1]]);
  else goTo(5);
}

function goBack10() {
  const order = getStepOrder();
  const last = order[order.length - 1];
  if (last) goTo(SEC_SCREEN[last]);
  else goTo(5);
}

function selHouse(el, name) {
  document.querySelectorAll('.house-card').forEach(c => c.classList.remove('selected'));
  el.classList.add('selected'); S.houseType = name;
}
function tci(el) { el.classList.toggle('checked'); }
function ttg(el) { el.classList.toggle('on'); }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PAN/ZOOM ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const CV = {};
const GRID = 32;

function mkCvState() {
  return { scale:1, ox:0, oy:0, minScale:0.5, maxScale:4,
           dragging:false, lastX:0, lastY:0, pinching:false, lastDist:0 };
}

function applyTransform(ctx, cx, W, H) {
  ctx.clearRect(0,0,W,H); ctx.save();
  ctx.translate(cx.ox, cx.oy); ctx.scale(cx.scale, cx.scale);
}

function attachPanZoom(el, cvName, onRedraw) {
  const cx = CV[cvName];
  el.addEventListener('touchstart', e=>{
    if (e.touches.length===2) {
      cx.pinching=true; cx.dragging=false;
      cx.lastDist=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,
                              e.touches[0].clientY-e.touches[1].clientY);
    } else if (e.touches.length===1 && !cx.pinching) {
      cx.dragging=true; cx.lastX=e.touches[0].clientX; cx.lastY=e.touches[0].clientY;
    }
  },{passive:true});
  el.addEventListener('touchmove', e=>{
    if (cx.pinching && e.touches.length===2) {
      const dist=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,
                             e.touches[0].clientY-e.touches[1].clientY);
      const ratio=dist/cx.lastDist; cx.lastDist=dist;
      const mid={ x:(e.touches[0].clientX+e.touches[1].clientX)/2,
                  y:(e.touches[0].clientY+e.touches[1].clientY)/2 };
      const r=el.getBoundingClientRect(), dpr=window.devicePixelRatio||1;
      const mx=(mid.x-r.left)*dpr, my=(mid.y-r.top)*dpr;
      const ns=Math.min(cx.maxScale,Math.max(cx.minScale,cx.scale*ratio));
      cx.ox=mx-(mx-cx.ox)*(ns/cx.scale); cx.oy=my-(my-cx.oy)*(ns/cx.scale); cx.scale=ns;
      onRedraw();
    } else if (cx.dragging && e.touches.length===1 && !cx.pinching) {
      const dpr=window.devicePixelRatio||1;
      cx.ox+=(e.touches[0].clientX-cx.lastX)*dpr;
      cx.oy+=(e.touches[0].clientY-cx.lastY)*dpr;
      cx.lastX=e.touches[0].clientX; cx.lastY=e.touches[0].clientY;
      onRedraw();
    }
    e.preventDefault();
  },{passive:false});
  el.addEventListener('touchend', e=>{
    if (e.touches.length<2) cx.pinching=false;
    if (e.touches.length===0) cx.dragging=false;
  },{passive:true});
  el.addEventListener('wheel', e=>{
    e.preventDefault();
    const r=el.getBoundingClientRect(), dpr=window.devicePixelRatio||1;
    const mx=(e.clientX-r.left)*dpr, my=(e.clientY-r.top)*dpr;
    const f=e.deltaY<0?1.15:0.87;
    const ns=Math.min(cx.maxScale,Math.max(cx.minScale,cx.scale*f));
    cx.ox=mx-(mx-cx.ox)*(ns/cx.scale); cx.oy=my-(my-cx.oy)*(ns/cx.scale); cx.scale=ns;
    onRedraw();
  },{passive:false});
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SNAP-CANVAS (—Ç–µ—Ä—Ä–∞—Å–∞, pool, pier, fence, paths-—Ç–æ—á–∫–∏)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function initSnapCanvas(name) {
  const wrap=document.getElementById('cw-'+name);
  const cv=document.getElementById('cv-'+name);
  const dpr=window.devicePixelRatio||1, sz=wrap.offsetWidth;
  cv.width=sz*dpr; cv.height=sz*dpr;
  cv.style.width=sz+'px'; cv.style.height=sz+'px';
  CV[name]=mkCvState();

  const newCv=cv.cloneNode(true); wrap.replaceChild(newCv, cv);
  attachPanZoom(wrap, name, ()=>drawSnapCanvas(name));

  // –†–∏—Å—É–µ–º –ü–û–°–õ–ï –∑–∞–º–µ–Ω—ã canvas (–∏–Ω–∞—á–µ clone —Å—Ç–∏—Ä–∞–µ—Ç —Ä–∏—Å—É–Ω–æ–∫)
  drawSnapCanvas(name);

  // –ö–ª–∏–∫ ‚Äî –¥–æ–±–∞–≤–∏—Ç—å —Ç–æ—á–∫—É —Å snap
  wrap.addEventListener('click', e=>{
    if (CV[name].pinching) return;
    const cvEl=document.getElementById('cv-'+name); if (!cvEl) return;
    const r=wrap.getBoundingClientRect(), dpr=window.devicePixelRatio||1;
    const sx=(e.clientX-r.left)*dpr, sy=(e.clientY-r.top)*dpr;
    const cx=CV[name];
    const wx=(sx-cx.ox)/cx.scale, wy=(sy-cx.oy)/cx.scale;
    const W=cvEl.width, step=W/GRID;
    S.pts[name].push({ x:Math.round(wx/step)*step/W, y:Math.round(wy/step)*step/W });
    drawSnapCanvas(name);
  });
}

// –í—ã—á–∏—Å–ª–∏—Ç—å –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –¥–æ–º–∞ –Ω–∞ canvas –≤ –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö 0..1
// –ù–∞ –æ—Å–Ω–æ–≤–µ —Ä–µ–∞–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –ø–ª–æ—â–∞–¥–∏. Canvas = GRID√óGRID –º —Å–µ—Ç–∫–∞.
function getHouseRectNorm() {
  const area = parseFloat(document.getElementById('v-area')?.value || 120);
  const RATIO = 1.6;
  const houseW = Math.sqrt(area / RATIO); // —à–∏—Ä–∏–Ω–∞ (–ø–æ Z / –ø–æ Y canvas)
  const houseL = houseW * RATIO;          // –¥–ª–∏–Ω–∞ (–ø–æ X)
  const gridSize = GRID;
  // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –¥–æ–º –Ω–∞ canvas
  const nx = (gridSize - houseL) / 2 / gridSize;
  const ny = (gridSize - houseW) / 2 / gridSize;
  const nw = houseL / gridSize;
  const nh = houseW / gridSize;
  return { nx, ny, nw, nh, houseL, houseW };
}

// –†–∏—Å–æ–≤–∞–Ω–∏–µ —Ä–∞–Ω–µ–µ –∑–∞–¥–∞–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –∫–∞–∫ —Ñ–æ–Ω –Ω–∞ canvas-—à–∞–≥–∞—Ö
// excludeName ‚Äî —Ç–µ–∫—É—â–∞—è —Å–µ–∫—Ü–∏—è (–Ω–µ —Ä–∏—Å—É–µ–º –µ—ë –ø–æ–≤—Ç–æ—Ä–Ω–æ, –æ–Ω–∞ —Ä–∏—Å—É–µ—Ç—Å—è –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω–æ–π —Å–ª–æ–π)
function drawPreviousLayers(ctx, W, H, cx, excludeName) {
  const sc = cx.scale || 1;

  // 1. –î–æ–º
  if (S.houseType !== '–£—á–∞—Å—Ç–æ–∫ –±–µ–∑ –¥–æ–º–∞') {
    const hr = getHouseRectNorm();
    const hx=hr.nx*W, hy=hr.ny*H, hw=hr.nw*W, hh=hr.nh*H;
    ctx.strokeStyle='#555'; ctx.lineWidth=2.5/sc; ctx.setLineDash([]);
    ctx.strokeRect(hx,hy,hw,hh);
    ctx.fillStyle='rgba(0,0,0,.06)'; ctx.fillRect(hx,hy,hw,hh);
    // –®—Ç—Ä–∏—Ö–æ–≤–∫–∞
    ctx.save();
    ctx.beginPath(); ctx.rect(hx,hy,hw,hh); ctx.clip();
    ctx.strokeStyle='rgba(0,0,0,.08)'; ctx.lineWidth=1/sc;
    for (let d = -Math.max(hw,hh); d < Math.max(hw,hh)*2; d += 8/sc) {
      ctx.beginPath(); ctx.moveTo(hx+d, hy); ctx.lineTo(hx+d-hh, hy+hh); ctx.stroke();
    }
    ctx.restore();
    ctx.fillStyle='#666'; ctx.font=`bold ${13/sc}px Roboto`; ctx.textAlign='center';
    ctx.fillText('–î–û–ú', hx+hw/2, hy+hh/2+5/sc);
    ctx.fillStyle='#888'; ctx.font=`${10/sc}px Roboto`;
    ctx.fillText(hr.houseL.toFixed(1)+'–º', hx+hw/2, hy-6/sc);
    ctx.save(); ctx.translate(hx-6/sc, hy+hh/2);
    ctx.rotate(-Math.PI/2); ctx.textAlign='center';
    ctx.fillText(hr.houseW.toFixed(1)+'–º', 0, 0); ctx.restore();
  }

  // –¶–≤–µ—Ç–∞ –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö —Å–ª–æ—ë–≤
  const layerStyles = {
    terrace:      { fill:'rgba(0,150,80,.12)',  stroke:'rgba(0,150,80,.5)',  label:'–¢–µ—Ä—Ä–∞—Å–∞' },
    pool_terrace: { fill:'rgba(0,80,200,.10)',  stroke:'rgba(0,80,200,.5)',  label:'–¢–µ—Ä—Ä. –±–∞—Å—Å–µ–π–Ω–∞' },
    pier:         { fill:'rgba(26,122,204,.10)',stroke:'rgba(26,122,204,.5)',label:'–ü—Ä–∏—á–∞–ª' },
    fence:        { fill:'none',                stroke:'rgba(0,0,0,.3)',     label:'–ó–∞–±–æ—Ä' },
  };

  // 2. –ü–æ–ª–∏–≥–æ–Ω—ã: terrace, pool_terrace, pier, fence
  for (const [secId, style] of Object.entries(layerStyles)) {
    if (secId === excludeName) continue;
    const tp = S.pts[secId];
    if (!tp || tp.length < 2) continue;
    ctx.beginPath(); ctx.moveTo(tp[0].x*W, tp[0].y*H);
    for (let i=1; i<tp.length; i++) ctx.lineTo(tp[i].x*W, tp[i].y*H);
    if (tp.length > 2 && secId !== 'fence') ctx.closePath();
    else if (secId === 'fence' && tp.length > 2) ctx.closePath();
    if (style.fill !== 'none') { ctx.fillStyle=style.fill; ctx.fill(); }
    ctx.strokeStyle=style.stroke; ctx.lineWidth=2/sc;
    ctx.setLineDash([6/sc,3/sc]); ctx.stroke(); ctx.setLineDash([]);
    // –ü–æ–¥–ø–∏—Å—å
    const centX = tp.reduce((s,p)=>s+p.x,0)/tp.length*W;
    const centY = tp.reduce((s,p)=>s+p.y,0)/tp.length*H;
    ctx.fillStyle=style.stroke; ctx.font=`${10/sc}px Roboto`; ctx.textAlign='center';
    ctx.fillText(style.label, centX, centY);
  }

  // 3. –î–æ—Ä–æ–∂–∫–∏ ‚Äî —Ä–∏—Å—É–µ–º –∫–∞–∫ –ø–æ–ª–æ—Å—É —É–∫–∞–∑–∞–Ω–Ω–æ–π —à–∏—Ä–∏–Ω—ã
  if (excludeName !== 'paths') {
    const pp = S.pts.paths;
    if (pp && pp.length >= 2) {
      const pathWidthCm = parseFloat(document.getElementById('v-paths-width')?.value || 120);
      const pathHalfW = (pathWidthCm / 100) / GRID * W / 2; // –ø–æ–ª–æ–≤–∏–Ω–∞ —à–∏—Ä–∏–Ω—ã –≤ –ø–∏–∫—Å–µ–ª—è—Ö canvas
      ctx.strokeStyle='rgba(51,102,0,.3)'; ctx.lineWidth=pathHalfW*2; ctx.lineCap='round'; ctx.lineJoin='round';
      ctx.beginPath(); ctx.moveTo(pp[0].x*W, pp[0].y*H);
      for (let i=1; i<pp.length; i++) ctx.lineTo(pp[i].x*W, pp[i].y*H);
      ctx.stroke();
      ctx.lineWidth=2/sc; // reset
      // –ü–æ–¥–ø–∏—Å—å
      const mid = pp[Math.floor(pp.length/2)];
      ctx.fillStyle='rgba(51,102,0,.6)'; ctx.font=`${10/sc}px Roboto`; ctx.textAlign='center';
      ctx.fillText('–î–æ—Ä–æ–∂–∫–∞', mid.x*W, mid.y*H - pathHalfW - 4/sc);
    }
  }

  // 4. –ö—Ä—ã–ª—å—Ü–æ (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —É–∂–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ ‚Äî —Ç.–µ. —Ç–µ–∫—É—â–∏–π —à–∞–≥ –∏–¥—ë—Ç –ü–û–°–õ–ï –∫—Ä—ã–ª—å—Ü–∞ –≤ –ø–æ—Ä—è–¥–∫–µ)
  // –ù–æ–≤—ã–π –ø–æ—Ä—è–¥–æ–∫: terrace ‚Üí porch ‚Üí paths ‚Üí fence ‚Üí pool_terrace ‚Üí pier
  const configOrder = ['terrace','porch','paths','fence','pool_terrace','pier'];
  const porchOrdIdx = configOrder.indexOf('porch');
  const curOrdIdx = configOrder.indexOf(excludeName);
  const porchDone = (curOrdIdx >= 0 && porchOrdIdx >= 0 && curOrdIdx > porchOrdIdx);
  if (excludeName !== 'porch' && S.sections.includes('porch') && porchDone) {
    const p = S.porch;
    const px=p.x*W, py=p.y*H, pw=p.w*W, ph=p.h*H;
    ctx.fillStyle='rgba(0,100,220,.10)'; ctx.fillRect(px,py,pw,ph);
    ctx.strokeStyle='rgba(0,100,220,.4)'; ctx.lineWidth=2/sc;
    ctx.setLineDash([4/sc,2/sc]); ctx.strokeRect(px,py,pw,ph); ctx.setLineDash([]);
    ctx.fillStyle='rgba(0,100,220,.5)'; ctx.font=`${10/sc}px Roboto`; ctx.textAlign='center';
    ctx.fillText('–ö—Ä—ã–ª—å—Ü–æ', px+pw/2, py+ph/2+4/sc);
  }
}

function drawSnapCanvas(name) {
  const cvEl=document.getElementById('cv-'+name); if (!cvEl) return;
  const ctx=cvEl.getContext('2d'), W=cvEl.width, H=cvEl.height;
  const cx=CV[name]||{scale:1,ox:0,oy:0};
  const pts=S.pts[name]||[];
  applyTransform(ctx,cx,W,H);

  ctx.fillStyle='#d9d9d9'; ctx.fillRect(0,0,W,H);

  // –°–µ—Ç–∫–∞
  const step=W/GRID;
  ctx.fillStyle='#bbb';
  for(let r=0;r<=GRID;r++) for(let c=0;c<=GRID;c++) {
    ctx.beginPath(); ctx.arc(c*step,r*step,2/cx.scale,0,Math.PI*2); ctx.fill();
  }

  // –ú–µ—Ç–∫–∏ –º–µ—Ç—Ä–æ–≤ (–∫–∞–∂–¥—ã–µ 5–º)
  ctx.fillStyle='#999'; ctx.font=`${9/cx.scale}px Roboto`; ctx.textAlign='center';
  for(let i=5;i<=GRID;i+=5) ctx.fillText(i+'–º', i*step, H-3/cx.scale);

  // –†–∞–Ω–µ–µ –∑–∞–¥–∞–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã (–¥–æ–º, —Ç–µ—Ä—Ä–∞—Å–∞, –¥–æ—Ä–æ–∂–∫–∏, –∫—Ä—ã–ª—å—Ü–æ –∏ —Ç.–¥.)
  drawPreviousLayers(ctx, W, H, cx, name);

  // –ü–æ–¥—Å–∫–∞–∑–∫–∞ (–µ—Å–ª–∏ –µ—â—ë –Ω–µ—Ç —Ç–æ—á–µ–∫)
  if (!pts.length) {
    ctx.fillStyle='#aaa'; ctx.font=`${13/cx.scale}px Roboto`; ctx.textAlign='center';
    const hint={terrace:'–ù–∞–∂–º–∏—Ç–µ —á—Ç–æ–±—ã –ø–æ—Å—Ç–∞–≤–∏—Ç—å —É–≥–æ–ª',pool_terrace:'–ù–∞–∂–º–∏—Ç–µ —á—Ç–æ–±—ã –ø–æ—Å—Ç–∞–≤–∏—Ç—å —É–≥–æ–ª',
                 pier:'–ù–∞–∂–º–∏—Ç–µ —á—Ç–æ–±—ã –ø–æ—Å—Ç–∞–≤–∏—Ç—å —É–≥–æ–ª',fence:'–ù–∞–∂–º–∏—Ç–µ —á—Ç–æ–±—ã –ø–æ—Å—Ç–∞–≤–∏—Ç—å —É–≥–æ–ª',
                 paths:'–ù–∞–∂–º–∏—Ç–µ —Ç–æ—á–∫–∏ –≤–¥–æ–ª—å –¥–æ—Ä–æ–∂–∫–∏'};
    ctx.fillText(hint[name]||'–ù–∞–∂–º–∏—Ç–µ —á—Ç–æ–±—ã –ø–æ—Å—Ç–∞–≤–∏—Ç—å —Ç–æ—á–∫—É', W/2, H*0.92);
  }

  // –ö–æ–Ω—Ç—É—Ä —Ç–µ–∫—É—â–µ–π —Å–µ–∫—Ü–∏–∏
  if (pts.length > 0) {
    const color = {terrace:'#000',pool_terrace:'#0050CC',pier:'#1a7acc',paths:'#336600',fence:'#000'}[name]||'#000';

    if (name === 'paths') {
      // –î–æ—Ä–æ–∂–∫–∏ ‚Äî —Ä–∏—Å—É–µ–º —à–∏—Ä–æ–∫–æ–π –ø–æ–ª–æ—Å–æ–π
      const pathWidthCm = parseFloat(document.getElementById('v-paths-width')?.value || 120);
      const pathW = (pathWidthCm / 100) / GRID * W;
      // –ü–æ–ª–æ—Å–∞
      ctx.strokeStyle='rgba(51,102,0,.25)'; ctx.lineWidth=pathW; ctx.lineCap='round'; ctx.lineJoin='round';
      ctx.beginPath(); ctx.moveTo(pts[0].x*W, pts[0].y*H);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x*W, pts[i].y*H);
      ctx.stroke();
      // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è
      ctx.strokeStyle=color; ctx.lineWidth=2/cx.scale; ctx.lineCap='butt';
      ctx.setLineDash([6/cx.scale,3/cx.scale]);
      ctx.beginPath(); ctx.moveTo(pts[0].x*W, pts[0].y*H);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x*W, pts[i].y*H);
      ctx.stroke(); ctx.setLineDash([]);
    } else {
      // –ü–æ–ª–∏–≥–æ–Ω—ã
      ctx.beginPath(); ctx.moveTo(pts[0].x*W,pts[0].y*H);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x*W,pts[i].y*H);
      if(pts.length>2) { ctx.closePath(); ctx.fillStyle='rgba(0,0,0,.08)'; ctx.fill(); }
      ctx.strokeStyle=color; ctx.lineWidth=2.5/cx.scale; ctx.stroke();
    }

    // –¢–æ—á–∫–∏
    pts.forEach((p,i)=>{
      ctx.beginPath(); ctx.arc(p.x*W,p.y*H,8/cx.scale,0,Math.PI*2);
      ctx.fillStyle='#fff'; ctx.fill();
      ctx.strokeStyle=color; ctx.lineWidth=2.5/cx.scale; ctx.stroke();
      ctx.fillStyle=color; ctx.font=`bold ${10/cx.scale}px Roboto`; ctx.textAlign='center';
      ctx.fillText(i+1,p.x*W,p.y*H+4/cx.scale);
    });
  }

  ctx.restore();
}

function undoPt(n) { S.pts[n].pop(); drawSnapCanvas(n); }
function clrPts(n) { S.pts[n]=[]; drawSnapCanvas(n); }

// –î–ª—è –¥–æ—Ä–æ–∂–µ–∫ - —Ç–æ—Ç –∂–µ snap-canvas, —É–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –≤—ã—à–µ
function initPathsCanvas() { initSnapCanvas('paths'); }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// –ö–†–´–õ–¨–¶–û: drag+resize –° –ü–û–ö–ê–ó–û–ú –¢–ï–†–†–ê–°–´ –í –§–û–ù–ï
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const HANDLE_R=18;
let porchDrag=null, porchDragStart=null;

function initPorchCanvas() {
  const wrap=document.getElementById('cw-porch');
  const cv=document.getElementById('cv-porch');
  const dpr=window.devicePixelRatio||1, sz=wrap.offsetWidth;
  cv.width=sz*dpr; cv.height=sz*dpr;
  cv.style.width=sz+'px'; cv.style.height=sz+'px';
  CV['porch']=mkCvState();
  const newCv=cv.cloneNode(true); wrap.replaceChild(newCv, cv);

  // –†–∏—Å—É–µ–º –ü–û–°–õ–ï –∑–∞–º–µ–Ω—ã canvas
  drawPorchCanvas();

  attachPorchEvents(wrap);
}

// –ï–¥–∏–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–±—ã—Ç–∏–π –∫—Ä—ã–ª—å—Ü–∞ ‚Äî —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–∞ pan vs drag
function attachPorchEvents(wrap) {
  const cx = CV['porch'];
  let touchId = null;     // id –ø–∞–ª—å—Ü–∞, —Ç–∞—â—è—â–µ–≥–æ –∫—Ä—ã–ª—å—Ü–æ
  let pinchActive = false;

  const getWorld = (clientX, clientY) => {
    const cvEl = document.getElementById('cv-porch');
    const r = wrap.getBoundingClientRect(), dpr = window.devicePixelRatio||1;
    return {
      x: ((clientX - r.left)*dpr - cx.ox) / cx.scale,
      y: ((clientY - r.top )*dpr - cx.oy) / cx.scale,
      W: cvEl.width,
    };
  };

  // ‚îÄ‚îÄ TOUCH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  wrap.addEventListener('touchstart', e=>{
    e.preventDefault();
    if (e.touches.length === 2) {
      // –î–≤–∞ –ø–∞–ª—å—Ü–∞ ‚Üí —Ç–æ–ª—å–∫–æ zoom, drag —Å–±—Ä–∞—Å—ã–≤–∞–µ–º
      pinchActive = true; porchDrag = null; touchId = null;
      cx.lastDist = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY);
      return;
    }
    if (e.touches.length === 1 && !pinchActive) {
      const t = e.touches[0];
      const {x,y,W} = getWorld(t.clientX, t.clientY);
      const hit = hitPorchHandle(x,y,W);
      if (hit) {
        porchDrag = hit;
        porchDragStart = {mx:x, my:y, ...S.porch};
        touchId = t.identifier;
      }
      // –ï—Å–ª–∏ –Ω–µ –≤ –∫—Ä—ã–ª—å—Ü–æ ‚Äî –Ω–∏—á–µ–≥–æ (pan —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –æ—Ç–∫–ª—é—á—ë–Ω,
      // —á—Ç–æ–±—ã –ø–µ—Ä–≤–æ–µ –∫–∞—Å–∞–Ω–∏–µ –≤—Å–µ–≥–¥–∞ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–ª–æ –∫—Ä—ã–ª—å—Ü–æ)
    }
  },{passive:false});

  wrap.addEventListener('touchmove', e=>{
    e.preventDefault();
    if (pinchActive && e.touches.length === 2) {
      const dist = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY);
      const ratio = dist / cx.lastDist; cx.lastDist = dist;
      const mid = {
        x: (e.touches[0].clientX + e.touches[1].clientX)/2,
        y: (e.touches[0].clientY + e.touches[1].clientY)/2,
      };
      const r=wrap.getBoundingClientRect(), dpr=window.devicePixelRatio||1;
      const mx=(mid.x-r.left)*dpr, my=(mid.y-r.top)*dpr;
      const ns=Math.min(cx.maxScale, Math.max(cx.minScale, cx.scale*ratio));
      cx.ox=mx-(mx-cx.ox)*(ns/cx.scale); cx.oy=my-(my-cx.oy)*(ns/cx.scale); cx.scale=ns;
      drawPorchCanvas(); return;
    }
    if (porchDrag && touchId !== null) {
      const t = [...e.touches].find(t=>t.identifier===touchId); if (!t) return;
      const {x,y,W} = getWorld(t.clientX, t.clientY);
      applyPorchDrag(x,y,W);
    }
  },{passive:false});

  wrap.addEventListener('touchend', e=>{
    if (e.touches.length < 2) pinchActive = false;
    if (e.touches.length === 0) { porchDrag=null; porchDragStart=null; touchId=null; }
  },{passive:true});

  // ‚îÄ‚îÄ –ú–´–®–¨ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  wrap.addEventListener('mousedown', e=>{
    const {x,y,W} = getWorld(e.clientX, e.clientY);
    const hit = hitPorchHandle(x,y,W);
    if (hit) {
      porchDrag=hit; porchDragStart={mx:x,my:y,...S.porch};
      wrap.style.cursor = hit==='move'?'move':'nwse-resize';
    }
  });
  document.addEventListener('mousemove', e=>{
    if (!porchDrag) return;
    const {x,y,W} = getWorld(e.clientX, e.clientY); applyPorchDrag(x,y,W);
  });
  document.addEventListener('mouseup', ()=>{ porchDrag=null; porchDragStart=null; wrap.style.cursor='default'; });

  // –ö–æ–ª–µ—Å–æ ‚Üí zoom
  wrap.addEventListener('wheel', e=>{
    e.preventDefault();
    const r=wrap.getBoundingClientRect(), dpr=window.devicePixelRatio||1;
    const mx=(e.clientX-r.left)*dpr, my=(e.clientY-r.top)*dpr;
    const f=e.deltaY<0?1.15:0.87;
    const ns=Math.min(cx.maxScale,Math.max(cx.minScale,cx.scale*f));
    cx.ox=mx-(mx-cx.ox)*(ns/cx.scale); cx.oy=my-(my-cx.oy)*(ns/cx.scale); cx.scale=ns;
    drawPorchCanvas();
  },{passive:false});
}

function getPorchRect(W) {
  const p=S.porch; return {x:p.x*W,y:p.y*W,w:p.w*W,h:p.h*W};
}
function hitPorchHandle(wx,wy,W) {
  const {x,y,w,h}=getPorchRect(W), R=HANDLE_R*2;
  for(const [id,cx,cy] of [['nw',x,y],['ne',x+w,y],['sw',x,y+h],['se',x+w,y+h]])
    if(Math.abs(wx-cx)<R && Math.abs(wy-cy)<R) return id;
  if(wx>=x&&wx<=x+w&&wy>=y&&wy<=y+h) return 'move';
  return null;
}
function applyPorchDrag(wx,wy,W) {
  const ds=porchDragStart, dx=(wx-ds.mx)/W, dy=(wy-ds.my)/W, mn=0.05, p=S.porch;
  if(porchDrag==='move'){ p.x=Math.max(0,Math.min(1-ds.w,ds.x+dx)); p.y=Math.max(0,Math.min(1-ds.h,ds.y+dy)); }
  else if(porchDrag==='se'){ p.w=Math.max(mn,ds.w+dx); p.h=Math.max(mn,ds.h+dy); }
  else if(porchDrag==='sw'){ const nw=Math.max(mn,ds.w-dx); p.x=ds.x+ds.w-nw; p.w=nw; p.h=Math.max(mn,ds.h+dy); }
  else if(porchDrag==='ne'){ p.w=Math.max(mn,ds.w+dx); const nh=Math.max(mn,ds.h-dy); p.y=ds.y+ds.h-nh; p.h=nh; }
  else if(porchDrag==='nw'){ const nw2=Math.max(mn,ds.w-dx); p.x=ds.x+ds.w-nw2; p.w=nw2; const nh2=Math.max(mn,ds.h-dy); p.y=ds.y+ds.h-nh2; p.h=nh2; }
  drawPorchCanvas();
}

function drawPorchCanvas() {
  const cvEl=document.getElementById('cv-porch'); if (!cvEl) return;
  const ctx=cvEl.getContext('2d'), W=cvEl.width, H=cvEl.height;
  const cx=CV['porch']||{scale:1,ox:0,oy:0};
  applyTransform(ctx,cx,W,H);

  ctx.fillStyle='#d9d9d9'; ctx.fillRect(0,0,W,H);

  // –°–µ—Ç–∫–∞
  const step=W/GRID; ctx.fillStyle='#bbb';
  for(let r=0;r<=GRID;r++) for(let c=0;c<=GRID;c++) {
    ctx.beginPath(); ctx.arc(c*step,r*step,2/cx.scale,0,Math.PI*2); ctx.fill();
  }
  // –ú–µ—Ç–∫–∏ –º–µ—Ç—Ä–æ–≤
  ctx.fillStyle='#999'; ctx.font=`${9/cx.scale}px Roboto`; ctx.textAlign='center';
  for(let i=5;i<=GRID;i+=5) ctx.fillText(i+'–º', i*step, H-3/cx.scale);

  // –†–∞–Ω–µ–µ –∑–∞–¥–∞–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã (–¥–æ–º, —Ç–µ—Ä—Ä–∞—Å–∞, –¥–æ—Ä–æ–∂–∫–∏ –∏ —Ç.–¥.)
  drawPreviousLayers(ctx, W, H, cx, 'porch');

  // –ö—Ä—ã–ª—å—Ü–æ
  const {x,y,w,h}=getPorchRect(W);
  ctx.fillStyle='rgba(0,100,220,.18)'; ctx.fillRect(x,y,w,h);
  ctx.strokeStyle='#0064DC'; ctx.lineWidth=2.5/cx.scale; ctx.strokeRect(x,y,w,h);
  ctx.fillStyle='#0064DC'; ctx.font=`bold ${11/cx.scale}px Roboto`; ctx.textAlign='center';
  ctx.fillText('–ö—Ä—ã–ª—å—Ü–æ',x+w/2,y+h/2+4/cx.scale);

  // –†—É—á–∫–∏
  [[x,y],[x+w,y],[x,y+h],[x+w,y+h]].forEach(([hpx,hpy])=>{
    ctx.beginPath(); ctx.arc(hpx,hpy,HANDLE_R/cx.scale,0,Math.PI*2);
    ctx.fillStyle='#fff'; ctx.fill();
    ctx.strokeStyle='#0064DC'; ctx.lineWidth=2/cx.scale; ctx.stroke();
  });
  ctx.restore();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// THREE.JS 3D –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let threeState = null; // {renderer, scene, camera, controls, houseGroup, animId}

// –ò–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ –≥—Ä—É–ø–ø—ã –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤
// threeState.wallMeshes = [] ‚Äî –≤—Å–µ —Å—Ç–µ–Ω–æ–≤—ã–µ mesh'–∏
// threeState.deckMeshes = [] ‚Äî –≤—Å–µ –¥–æ—Å–∫–∏ —Ç–µ—Ä—Ä–∞—Å—ã (–≤–µ—Ä—Ö–Ω—è—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å)
// threeState.porchMeshes = [] ‚Äî –¥–æ—Å–∫–∏ –∫—Ä—ã–ª—å—Ü–∞

function init3dCanvas(targetSlotId) {
  const targetSlot = document.getElementById(targetSlotId || 'three-container');
  if (!targetSlot || typeof THREE === 'undefined') return;

  // –ï—Å–ª–∏ —É–∂–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω ‚Äî –ø–µ—Ä–µ–º–µ—â–∞–µ–º renderer –≤ —Ü–µ–ª–µ–≤–æ–π —Å–ª–æ—Ç –∏ –æ–±–Ω–æ–≤–ª—è–µ–º
  if (threeState) {
    moveThreeTo(targetSlotId);
    resizeThree();
    buildScene3d();
    return;
  }

  const W = targetSlot.offsetWidth || 360;
  const H = targetSlot.offsetHeight || 360;

  // --- Renderer ---
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setSize(W, H);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.1;
  renderer.outputEncoding = THREE.sRGBEncoding;
  targetSlot.appendChild(renderer.domElement);
  renderer.domElement.style.cssText = 'position:absolute;inset:0;width:100%;height:100%;display:block;border-radius:12px;';

  // --- Scene ---
  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(new THREE.Color(0.65, 0.78, 0.95), 40, 90);

  // --- Camera ---
  const camera = new THREE.PerspectiveCamera(45, W / H, 0.1, 200);
  camera.position.set(18, 12, 18);

  // --- Controls ---
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.target.set(4, 2, 2.5);
  controls.minDistance = 4;
  controls.maxDistance = 50;
  controls.maxPolarAngle = Math.PI / 2.05;

  // --- Sky sphere ---
  const skyGeo = new THREE.SphereGeometry(80, 32, 16);
  const skyMat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    depthWrite: false,
    uniforms: {
      skyTop:    { value: new THREE.Color(0.25, 0.45, 0.85) },
      skyHoriz:  { value: new THREE.Color(0.65, 0.78, 0.95) },
      ground:    { value: new THREE.Color(0.28, 0.4, 0.22) },
    },
    vertexShader: `
      varying vec3 vPos;
      void main() { vPos = normalize(position); gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
    `,
    fragmentShader: `
      uniform vec3 skyTop, skyHoriz, ground;
      varying vec3 vPos;
      void main() {
        float e = vPos.y;
        vec3 col = mix(skyHoriz, skyTop, smoothstep(0.0, 0.5, e));
        col = mix(ground * 0.5, col, smoothstep(-0.05, 0.05, e));
        gl_FragColor = vec4(col, 1.0);
      }
    `
  });
  scene.add(new THREE.Mesh(skyGeo, skyMat));

  // --- Lights ---
  scene.add(new THREE.AmbientLight(0xfff8e8, 0.6));
  const sun = new THREE.DirectionalLight(0xfff4e0, 1.2);
  sun.position.set(12, 20, 8);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048, 2048);
  sun.shadow.camera.left = -15; sun.shadow.camera.right = 15;
  sun.shadow.camera.top  =  15; sun.shadow.camera.bottom = -15;
  sun.shadow.camera.near = 1;   sun.shadow.camera.far = 50;
  sun.shadow.bias = -0.0003;
  sun.shadow.radius = 3;
  scene.add(sun);
  scene.add(new THREE.HemisphereLight(0x87ceeb, 0x4a7c3f, 0.5));

  // --- Ground ---
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(100, 100),
    new THREE.MeshStandardMaterial({ color: 0x4a7c3f, roughness: 0.95, metalness: 0 })
  );
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // --- House group ---
  const houseGroup = new THREE.Group();
  scene.add(houseGroup);

  threeState = { renderer, scene, camera, controls, houseGroup, animId: null,
                 wallMeshes: [], deckMeshes: [], porchMeshes: [],
                 stepMeshes: [], fenceMeshes: [], railingMeshes: [],
                 currentSlot: targetSlotId };

  // --- Animation loop ---
  function animate() {
    threeState.animId = requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  buildScene3d();
}

// –ü–µ—Ä–µ–º–µ—â–∞–µ–º canvas Three.js –≤ –¥—Ä—É–≥–æ–π —Å–ª–æ—Ç
function moveThreeTo(slotId) {
  if (!threeState) return;
  const target = document.getElementById(slotId);
  if (!target) return;
  if (threeState.currentSlot === slotId) return;
  // –ü–µ—Ä–µ–º–µ—â–∞–µ–º DOM-—ç–ª–µ–º–µ–Ω—Ç renderer'–∞
  target.appendChild(threeState.renderer.domElement);
  threeState.currentSlot = slotId;
  // –ü–µ—Ä–µ-–ø—Ä–∏–≤—è–∑—ã–≤–∞–µ–º OrbitControls –∫ –Ω–æ–≤–æ–º—É DOM
  threeState.controls.dispose();
  threeState.controls = new THREE.OrbitControls(threeState.camera, threeState.renderer.domElement);
  threeState.controls.enableDamping = true;
  threeState.controls.dampingFactor = 0.08;
  threeState.controls.minDistance = 4;
  threeState.controls.maxDistance = 50;
  threeState.controls.maxPolarAngle = Math.PI / 2.05;
}

function resizeThree() {
  if (!threeState) return;
  const wrap = document.getElementById(threeState.currentSlot);
  if (!wrap) return;
  const W = wrap.offsetWidth, H = wrap.offsetHeight;
  if (!W || !H) return;
  const { renderer, camera } = threeState;
  camera.aspect = W / H;
  camera.updateProjectionMatrix();
  renderer.setSize(W, H);
}

// –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –Ω–∞ —à–∞–≥–∞—Ö 2-4
let paramChangeTimer = null;
function onParamChange() {
  clearTimeout(paramChangeTimer);
  paramChangeTimer = setTimeout(() => {
    if (threeState) buildScene3d();
  }, 150);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SHARED 3D MATERIALS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function getHouseMats() {
  return {
    wall:   new THREE.MeshStandardMaterial({ color: 0xf5e6c8, roughness: 0.85, metalness: 0.02 }),
    base:   new THREE.MeshStandardMaterial({ color: 0x8a8278, roughness: 0.90, metalness: 0.05 }),
    roof:   new THREE.MeshStandardMaterial({ color: 0x8b3a3a, roughness: 0.70, metalness: 0.10, side: THREE.DoubleSide }),
    glass:  new THREE.MeshStandardMaterial({ color: 0x6baed6, roughness: 0.05, metalness: 0.5, transparent: true, opacity: 0.6 }),
    frame:  new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.40, metalness: 0.15 }),
    door:   new THREE.MeshStandardMaterial({ color: 0x5c3a1e, roughness: 0.75, metalness: 0.05 }),
    // –¢–µ—Ä—Ä–∞—Å–∞ / –∫—Ä—ã–ª—å—Ü–æ
    deck:   new THREE.MeshStandardMaterial({ color: 0xC8A96E, roughness: 0.72, metalness: 0.02 }),
    joist:  new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.85, metalness: 0.15 }),
    post:   new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.80, metalness: 0.20 }),
    step:   new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.80, metalness: 0.05 }),
  };
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN SCENE BUILDER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function buildScene3d() {
  if (!threeState || typeof THREE === 'undefined') return;
  const { houseGroup, controls } = threeState;

  // Clear everything
  clearGroup(houseGroup);
  threeState.wallMeshes = [];
  threeState.deckMeshes = [];
  threeState.porchMeshes = [];
  threeState.stepMeshes = [];
  threeState.fenceMeshes = [];
  threeState.railingMeshes = [];

  const M = getHouseMats();

  // Apply active sample color to relevant section
  if (S.activeSample && S.activeSample.color) {
    const sec = getActive()[S.curSec];
    const secId = sec ? sec.id : 'terrace';
    if (secId === 'facade') {
      M.wall.color.set(S.activeSample.color);
    } else if (secId === 'porch') {
      M.step.color.set(S.activeSample.color);
    } else {
      M.deck.color.set(S.activeSample.color);
    }
  }

  const isNoHouse = (S.houseType === '–£—á–∞—Å—Ç–æ–∫ –±–µ–∑ –¥–æ–º–∞');

  // Pull params
  const area      = parseFloat(document.getElementById('v-area')?.value || 120);
  const wallH     = parseFloat(document.getElementById('v-floor')?.value || 400) / 100;
  const foundH    = parseFloat(document.getElementById('v-found')?.value || 80) / 100;
  const RATIO     = 1.6;
  const wt        = 0.2;

  const houseW = Math.sqrt(area / RATIO);
  const houseL = houseW * RATIO;
  const wh     = Math.min(Math.max(wallH, 2), 5);
  const bh     = Math.max(foundH, 0.1);

  // ‚îÄ‚îÄ BUILD HOUSE ‚îÄ‚îÄ
  if (!isNoHouse) {
    buildHouseMeshes(houseGroup, M, houseL, houseW, wh, bh, wt);
  }

  // ‚îÄ‚îÄ BUILD TERRACE ‚îÄ‚îÄ
  if (S.sections.includes('terrace') && S.pts.terrace.length >= 3) {
    const terraceH = isNoHouse ? 0.35 : bh;
    buildTerrace3d(houseGroup, M, S.pts.terrace, terraceH, houseL, houseW, 'deckMeshes');
  }

  // ‚îÄ‚îÄ BUILD POOL TERRACE ‚îÄ‚îÄ
  if (S.sections.includes('pool_terrace') && S.pts.pool_terrace.length >= 3) {
    const terraceH = isNoHouse ? 0.35 : bh;
    buildTerrace3d(houseGroup, M, S.pts.pool_terrace, terraceH, houseL, houseW, 'deckMeshes');
  }

  // ‚îÄ‚îÄ BUILD PIER ‚îÄ‚îÄ
  if (S.sections.includes('pier') && S.pts.pier.length >= 3) {
    buildTerrace3d(houseGroup, M, S.pts.pier, 0.5, houseL, houseW, 'deckMeshes');
  }

  // ‚îÄ‚îÄ BUILD PATHS ‚îÄ‚îÄ
  if (S.sections.includes('paths') && S.pts.paths.length >= 2) {
    buildPaths3d(houseGroup, M, S.pts.paths, houseL, houseW);
  }

  // ‚îÄ‚îÄ BUILD PORCH ‚îÄ‚îÄ
  if (S.sections.includes('porch') && !isNoHouse) {
    buildPorch3d(houseGroup, M, S.porch, houseL, houseW, bh);
  }

  // ‚îÄ‚îÄ BUILD FENCE ‚îÄ‚îÄ
  if (S.sections.includes('fence') && S.pts.fence.length >= 2) {
    buildFence3d(houseGroup, M, S.pts.fence, houseL, houseW);
  }

  // ‚îÄ‚îÄ BUILD TERRACE RAILING (–ø–æ —Ç–æ–≥–ª—É ¬´–ù—É–∂–Ω–æ –æ–≥—Ä–∞–∂–¥–µ–Ω–∏–µ¬ª –Ω–∞ —à–∞–≥–µ —Ç–µ—Ä—Ä–∞—Å—ã) ‚îÄ‚îÄ
  const terraceRailingOn = document.querySelector('.tg[data-id="terrace-railing"]')?.classList.contains('on');
  if (terraceRailingOn && S.pts.terrace.length >= 3) {
    const terraceH = isNoHouse ? 0.35 : bh;
    buildRailing3d(houseGroup, M, S.pts.terrace, terraceH, houseL, houseW);
  }

  // Center camera
  const cx = isNoHouse ? 0 : houseL/2;
  const cy = isNoHouse ? 1 : (bh+wh)/2;
  const cz = isNoHouse ? 0 : houseW/2;
  controls.target.set(cx, cy, cz);
  controls.update();
}

function clearGroup(group) {
  while (group.children.length) {
    const c = group.children[0];
    group.remove(c);
    if (c.geometry) c.geometry.dispose();
    if (c.children) clearGroup(c);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// HOUSE BUILDER (–¥–æ–º ‚Äî —Å—É—â–µ—Å—Ç–≤—É—é—â–∞—è –ª–æ–≥–∏–∫–∞)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function buildHouseMeshes(parent, M, length, width, wh, bh, wt) {
  const box = (sx, sy, sz) => new THREE.BoxGeometry(sx, sy, sz);
  const mesh = (geo, mat) => { const m = new THREE.Mesh(geo, mat); m.castShadow = true; m.receiveShadow = true; return m; };

  // Basement
  const bm = mesh(box(length + 0.2, bh, width + 0.2), M.base);
  bm.position.set(length/2, bh/2, width/2);
  parent.add(bm);

  // Window / door constants
  const WWIN = 0.9, HWIN = 1.2, YWIN = 1.0;
  const WDOOR = 1.0, HDOOR = 2.2;

  function xWallWithWins(len, wins) {
    const g = new THREE.Group();
    const sorted = [...wins].sort((a,b)=>a.x-b.x);
    const botH = sorted.length ? Math.min(...sorted.map(w=>w.y)) : wh;
    const topStart = sorted.length ? Math.max(...sorted.map(w=>w.y+w.h)) : wh;
    if (botH > 0.01) { const m=mesh(box(len,botH,wt),M.wall); m.position.set(len/2,botH/2,wt/2); g.add(m); threeState.wallMeshes.push(m); }
    if (wh - topStart > 0.01) { const m=mesh(box(len,wh-topStart,wt),M.wall); m.position.set(len/2,topStart+(wh-topStart)/2,wt/2); g.add(m); threeState.wallMeshes.push(m); }
    let prev=0;
    for (const w of sorted) {
      if (w.x-prev>0.01) { const m=mesh(box(w.x-prev,topStart-botH,wt),M.wall); m.position.set(prev+(w.x-prev)/2,botH+(topStart-botH)/2,wt/2); g.add(m); threeState.wallMeshes.push(m); }
      const gm=new THREE.Mesh(box(w.w,w.h,wt*0.3),M.glass); gm.position.set(w.x+w.w/2,w.y+w.h/2,wt/2); g.add(gm);
      const ft=0.04, fd=wt+0.06;
      [[w.w+ft*2,ft,fd,w.x+w.w/2,w.y+w.h+ft/2],[w.w+ft*2,ft,fd,w.x+w.w/2,w.y-ft/2],
       [ft,w.h,fd,w.x-ft/2,w.y+w.h/2],[ft,w.h,fd,w.x+w.w+ft/2,w.y+w.h/2],
       [w.w,ft*0.7,fd*0.7,w.x+w.w/2,w.y+w.h/2],[ft*0.7,w.h,fd*0.7,w.x+w.w/2,w.y+w.h/2]
      ].forEach(([sx,sy,sz,px,py])=>{ const m=new THREE.Mesh(box(sx,sy,sz),M.frame); m.position.set(px,py,wt/2); g.add(m); });
      prev=w.x+w.w;
    }
    if (len-prev>0.01) { const m=mesh(box(len-prev,topStart-botH,wt),M.wall); m.position.set(prev+(len-prev)/2,botH+(topStart-botH)/2,wt/2); g.add(m); threeState.wallMeshes.push(m); }
    return g;
  }

  function zWallWithDoor(zLen, hasDoor, hasWins) {
    const g = new THREE.Group();
    const holes = [];
    if (hasDoor) { const dz = zLen/2 - WDOOR/2; holes.push({z:dz,y:0,w:WDOOR,h:HDOOR,isDoor:true}); }
    if (hasWins) {
      const dz = zLen/2 - WDOOR/2;
      const leftC = (dz - 0.3) / 2 - WWIN/2;
      if (leftC >= 0.1) holes.push({z:leftC, y:YWIN, w:WWIN, h:HWIN});
      const rightC = (dz+WDOOR+0.3 + zLen)/2 - WWIN/2;
      if (rightC+WWIN <= zLen-0.1) holes.push({z:rightC, y:YWIN, w:WWIN, h:HWIN});
    }
    if (!holes.length) { const m=mesh(box(wt,wh,zLen),M.wall); m.position.set(wt/2,wh/2,zLen/2); g.add(m); threeState.wallMeshes.push(m); return g; }
    const sorted=[...holes].sort((a,b)=>a.z-b.z);
    const topS = Math.max(...sorted.map(h=>h.y+h.h));
    if (wh-topS>0.01){ const m=mesh(box(wt,wh-topS,zLen),M.wall); m.position.set(wt/2,topS+(wh-topS)/2,zLen/2); g.add(m); threeState.wallMeshes.push(m); }
    let prev=0;
    for (const h of sorted) {
      if (h.z-prev>0.01){ const m=mesh(box(wt,topS,h.z-prev),M.wall); m.position.set(wt/2,topS/2,prev+(h.z-prev)/2); g.add(m); threeState.wallMeshes.push(m); }
      if (h.y>0.01){ const m=mesh(box(wt,h.y,h.w),M.wall); m.position.set(wt/2,h.y/2,h.z+h.w/2); g.add(m); threeState.wallMeshes.push(m); }
      const fillerH=topS-(h.y+h.h);
      if (fillerH>0.01){ const m=mesh(box(wt,fillerH,h.w),M.wall); m.position.set(wt/2,(h.y+h.h)+fillerH/2,h.z+h.w/2); g.add(m); threeState.wallMeshes.push(m); }
      const fm=new THREE.Mesh(box(wt*0.3,h.h,h.w), h.isDoor?M.door:M.glass);
      fm.position.set(wt/2,h.y+h.h/2,h.z+h.w/2); g.add(fm);
      const ft=0.04,fd=wt+0.08;
      if (!h.isDoor) {
        [[fd,ft,h.w+ft*2,wt/2,h.y+h.h+ft/2,h.z+h.w/2],[fd,ft,h.w+ft*2,wt/2,h.y-ft/2,h.z+h.w/2],
         [fd,h.h,ft,wt/2,h.y+h.h/2,h.z-ft/2],[fd,h.h,ft,wt/2,h.y+h.h/2,h.z+h.w+ft/2],
         [fd*0.7,ft*0.7,h.w,wt/2,h.y+h.h/2,h.z+h.w/2],[fd*0.7,h.h,ft*0.7,wt/2,h.y+h.h/2,h.z+h.w/2]
        ].forEach(([sx,sy,sz,px,py,pz])=>{ const m=new THREE.Mesh(box(sx,sy,sz),M.frame); m.position.set(px,py,pz); g.add(m); });
      } else {
        [[fd,ft,h.w+ft*2,wt/2,h.y+h.h+ft/2,h.z+h.w/2],[fd,h.h,ft,wt/2,h.y+h.h/2,h.z-ft/2],[fd,h.h,ft,wt/2,h.y+h.h/2,h.z+h.w+ft/2]
        ].forEach(([sx,sy,sz,px,py,pz])=>{ const m=new THREE.Mesh(box(sx,sy,sz),M.frame); m.position.set(px,py,pz); g.add(m); });
      }
      prev=h.z+h.w;
    }
    if (zLen-prev>0.01){ const m=mesh(box(wt,topS,zLen-prev),M.wall); m.position.set(wt/2,topS/2,prev+(zLen-prev)/2); g.add(m); threeState.wallMeshes.push(m); }
    return g;
  }

  const winCount = Math.max(0, Math.round(length / (WWIN * 2.9)));
  const winIndent = winCount > 0 ? (length - winCount * WWIN) / (winCount + 1) : length;
  const wins = [];
  for (let i=0;i<winCount;i++) wins.push({x: winIndent + (WWIN + winIndent)*i, y:YWIN, w:WWIN, h:HWIN});

  const lw = xWallWithWins(length, wins); lw.position.set(0, bh, 0); parent.add(lw);
  const rw = xWallWithWins(length, wins); rw.position.set(0, bh, width - wt); parent.add(rw);
  const zInner = width - wt*2;
  const bk = zWallWithDoor(zInner, false, true); bk.position.set(0, bh, wt); parent.add(bk);
  const fw = zWallWithDoor(zInner, true, true); fw.position.set(length-wt, bh, wt); parent.add(fw);

  // Roof
  const rh = 2.0, oh=0.3;
  const x0=-oh, x1=length+oh, z0=-oh, z1=width+oh, zMid=width/2;
  const yBase=bh+wh, yPeak=bh+wh+rh;
  const verts = new Float32Array([
    x0,yBase,z0, x1,yBase,z0, x1,yPeak,zMid,  x0,yBase,z0, x1,yPeak,zMid, x0,yPeak,zMid,
    x0,yBase,z1, x0,yPeak,zMid, x1,yPeak,zMid, x0,yBase,z1, x1,yPeak,zMid, x1,yBase,z1,
    x1,yBase,z0, x1,yBase,z1, x1,yPeak,zMid,
    x0,yBase,z1, x0,yBase,z0, x0,yPeak,zMid,
    x0,yBase,z0, x0,yBase,z1, x1,yBase,z1, x0,yBase,z0, x1,yBase,z1, x1,yBase,z0,
  ]);
  const roofGeo = new THREE.BufferGeometry();
  roofGeo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
  roofGeo.computeVertexNormals();
  const roofMesh = new THREE.Mesh(roofGeo, M.roof);
  roofMesh.castShadow = true;
  parent.add(roofMesh);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TERRACE BUILDER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö —Ç–æ—á–µ–∫ (0..1 –∏–∑ canvas) –≤ –º–∏—Ä–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
// Canvas: 16√ó16–º —Å–µ—Ç–∫–∞. –î–æ–º —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω –Ω–∞ canvas.
// 3D: –¥–æ–º –æ—Ç (0, 0, 0) –¥–æ (houseL, _, houseW).
// –ù—É–∂–Ω–æ: canvas-coord –¥–æ–º–∞ ‚Üí 3D-coord –¥–æ–º–∞ (—Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ)
function canvasToWorld(pts, houseL, houseW) {
  const gridSize = GRID;
  // –î–æ–º –Ω–∞ canvas –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –≤ (centerX - houseL/2, centerY - houseW/2)
  // –í –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö: ((gridSize - houseL)/2 / gridSize, ...)
  // –í 3D –¥–æ–º –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –≤ (0, 0)
  // –°–º–µ—â–µ–Ω–∏–µ: worldX = canvasX_meters - houseOffsetX_meters
  const offsetX = (gridSize - houseL) / 2;
  const offsetZ = (gridSize - houseW) / 2;
  return pts.map(p => ({
    x: p.x * gridSize - offsetX,  // –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –Ω–∞—á–∞–ª–∞ –¥–æ–º–∞
    z: p.y * gridSize - offsetZ   // canvas Y ‚Üí world Z
  }));
}

function buildTerrace3d(parent, M, pts, deckHeight, houseL, houseW, meshArrayName) {
  if (pts.length < 3) return;
  const trackArray = meshArrayName || 'deckMeshes';

  const box = (sx, sy, sz) => new THREE.BoxGeometry(sx, sy, sz);
  const mesh = (geo, mat) => { const m = new THREE.Mesh(geo, mat); m.castShadow = true; m.receiveShadow = true; return m; };

  const worldPts = canvasToWorld(pts, houseL, houseW);

  // Bounding box
  const minX = Math.min(...worldPts.map(p=>p.x));
  const maxX = Math.max(...worldPts.map(p=>p.x));
  const minZ = Math.min(...worldPts.map(p=>p.z));
  const maxZ = Math.max(...worldPts.map(p=>p.z));
  const spanX = maxX - minX;
  const spanZ = maxZ - minZ;

  if (spanX < 0.3 || spanZ < 0.3) return; // —Å–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–∞—è

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ—á–∫–∏ –≤–Ω—É—Ç—Ä–∏ –ø–æ–ª–∏–≥–æ–Ω–∞ (ray casting)
  function pointInPoly(px, pz) {
    let inside = false;
    for (let i=0, j=worldPts.length-1; i<worldPts.length; j=i++) {
      const xi=worldPts[i].x, zi=worldPts[i].z;
      const xj=worldPts[j].x, zj=worldPts[j].z;
      if ((zi > pz) !== (zj > pz) && px < (xj-xi)*(pz-zi)/(zj-zi)+xi) inside = !inside;
    }
    return inside;
  }

  const boardW = 0.14;   // —à–∏—Ä–∏–Ω–∞ –¥–æ—Å–∫–∏ 140–º–º
  const boardH = 0.022;  // —Ç–æ–ª—â–∏–Ω–∞ 22–º–º
  const gap    = 0.005;  // –∑–∞–∑–æ—Ä 5–º–º
  const joistH = 0.05;   // –≤—ã—Å–æ—Ç–∞ –ª–∞–≥–∏
  const joistW = 0.05;   // —à–∏—Ä–∏–Ω–∞ –ª–∞–≥–∏
  const joistStep = 0.4; // —à–∞–≥ –ª–∞–≥
  const postW  = 0.08;   // —Å–µ—á–µ–Ω–∏–µ –æ–ø–æ—Ä—ã
  const postStep = 1.0;  // —à–∞–≥ –æ–ø–æ—Ä

  const deckY = deckHeight;          // –≤–µ—Ä—Ö –Ω–∞—Å—Ç–∏–ª–∞
  const boardBot = deckY - boardH;   // –Ω–∏–∑ –¥–æ—Å–∫–∏
  const joistBot = boardBot - joistH;// –Ω–∏–∑ –ª–∞–≥–∏

  const terraceGroup = new THREE.Group();

  // ‚îÄ‚îÄ –û–ü–û–†–´ (posts) ‚îÄ‚îÄ
  for (let px = minX + postStep/2; px <= maxX; px += postStep) {
    for (let pz = minZ + postStep/2; pz <= maxZ; pz += postStep) {
      if (!pointInPoly(px, pz)) continue;
      const ph = joistBot; // –æ—Ç –∑–µ–º–ª–∏ –¥–æ –Ω–∏–∑–∞ –ª–∞–≥
      if (ph < 0.05) continue;
      const post = mesh(box(postW, ph, postW), M.post);
      post.position.set(px, ph/2, pz);
      terraceGroup.add(post);
    }
  }

  // ‚îÄ‚îÄ –õ–ê–ì–ò (joists) ‚Äî –≤–¥–æ–ª—å X ‚îÄ‚îÄ
  for (let jz = minZ + joistStep/2; jz <= maxZ; jz += joistStep) {
    // –ù–∞–π—Ç–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –ª–∏–Ω–∏–∏ z=jz —Å –ø–æ–ª–∏–≥–æ–Ω–æ–º
    const intersections = [];
    for (let i=0, j=worldPts.length-1; i<worldPts.length; j=i++) {
      const z1=worldPts[j].z, z2=worldPts[i].z;
      const x1=worldPts[j].x, x2=worldPts[i].x;
      if ((z1<=jz && z2>jz) || (z2<=jz && z1>jz)) {
        const t = (jz - z1) / (z2 - z1);
        intersections.push(x1 + t*(x2-x1));
      }
    }
    intersections.sort((a,b)=>a-b);
    // –†–∏—Å—É–µ–º –ª–∞–≥–∏ –º–µ–∂–¥—É –ø–∞—Ä–∞–º–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
    for (let k=0; k<intersections.length-1; k+=2) {
      const x1 = intersections[k], x2 = intersections[k+1];
      const len = x2 - x1;
      if (len < 0.1) continue;
      const j = mesh(box(len, joistH, joistW), M.joist);
      j.position.set(x1 + len/2, joistBot + joistH/2, jz);
      terraceGroup.add(j);
    }
  }

  // ‚îÄ‚îÄ –î–û–°–ö–ò (boards) ‚Äî –≤–¥–æ–ª—å Z ‚îÄ‚îÄ
  for (let bx = minX + boardW/2; bx <= maxX; bx += boardW + gap) {
    // –ù–∞–π—Ç–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –ª–∏–Ω–∏–∏ x=bx —Å –ø–æ–ª–∏–≥–æ–Ω–æ–º
    const intersections = [];
    for (let i=0, j=worldPts.length-1; i<worldPts.length; j=i++) {
      const x1=worldPts[j].x, x2=worldPts[i].x;
      const z1=worldPts[j].z, z2=worldPts[i].z;
      if ((x1<=bx && x2>bx) || (x2<=bx && x1>bx)) {
        const t = (bx - x1) / (x2 - x1);
        intersections.push(z1 + t*(z2-z1));
      }
    }
    intersections.sort((a,b)=>a-b);
    for (let k=0; k<intersections.length-1; k+=2) {
      const z1 = intersections[k], z2 = intersections[k+1];
      const len = z2 - z1;
      if (len < 0.05) continue;
      const b = mesh(box(boardW, boardH, len), M.deck);
      b.position.set(bx, boardBot + boardH/2, z1 + len/2);
      terraceGroup.add(b);
      threeState[trackArray].push(b);
    }
  }

  parent.add(terraceGroup);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PORCH BUILDER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function buildPorch3d(parent, M, porch, houseL, houseW, bh) {
  const box = (sx, sy, sz) => new THREE.BoxGeometry(sx, sy, sz);
  const mesh = (geo, mat) => { const m = new THREE.Mesh(geo, mat); m.castShadow = true; m.receiveShadow = true; return m; };

  const gridSize = GRID;
  const offsetX = (gridSize - houseL) / 2;
  const offsetZ = (gridSize - houseW) / 2;

  // –ö—Ä—ã–ª—å—Ü–æ –≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö (—Ç–∞ –∂–µ —Å–∏—Å—Ç–µ–º–∞, —á—Ç–æ canvasToWorld)
  const px = porch.x * gridSize - offsetX;
  const pz = porch.y * gridSize - offsetZ;
  const pw = porch.w * gridSize;
  const pd = porch.h * gridSize;

  if (pw < 0.2 || pd < 0.2) return;

  const porchGroup = new THREE.Group();

  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç—É–ø–µ–Ω–µ–π: –æ—Ç –±–ª–∏–∂–∞–π—à–µ–π —Å—Ç–µ–Ω—ã –¥–æ–º–∞ –Ω–∞—Ä—É–∂—É
  // –î–æ–º –≤ 3D: X –æ—Ç 0 –¥–æ houseL, Z –æ—Ç 0 –¥–æ houseW
  // –¶–µ–Ω—Ç—Ä –∫—Ä—ã–ª—å—Ü–∞
  const cx = px + pw/2;
  const cz = pz + pd/2;

  // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –∫–∞–∂–¥–æ–π —Å—Ç–µ–Ω—ã –¥–æ–º–∞
  const distFront = Math.abs(cz - houseW);  // –ø–µ—Ä–µ–¥–Ω—è—è —Å—Ç–µ–Ω–∞ (Z = houseW)
  const distBack  = Math.abs(cz);           // –∑–∞–¥–Ω—è—è —Å—Ç–µ–Ω–∞ (Z = 0)
  const distRight = Math.abs(cx - houseL);  // –ø—Ä–∞–≤–∞—è —Å—Ç–µ–Ω–∞ (X = houseL)
  const distLeft  = Math.abs(cx);           // –ª–µ–≤–∞—è —Å—Ç–µ–Ω–∞ (X = 0)
  const minDist = Math.min(distFront, distBack, distRight, distLeft);

  // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç—É–ø–µ–Ω–µ–π (dx, dz) ‚Äî –æ—Ç –¥–æ–º–∞ –Ω–∞—Ä—É–∂—É
  let stepDirX = 0, stepDirZ = 0;
  if (minDist === distFront) stepDirZ = 1;      // —Å—Ç—É–ø–µ–Ω–∏ –∏–¥—É—Ç –≤ +Z
  else if (minDist === distBack) stepDirZ = -1;  // —Å—Ç—É–ø–µ–Ω–∏ –∏–¥—É—Ç –≤ -Z
  else if (minDist === distRight) stepDirX = 1;  // —Å—Ç—É–ø–µ–Ω–∏ –∏–¥—É—Ç –≤ +X
  else stepDirX = -1;                            // —Å—Ç—É–ø–µ–Ω–∏ –∏–¥—É—Ç –≤ -X

  // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—É–ø–µ–Ω–µ–π
  const stepH = 0.17;
  const stepD = 0.28;
  const boardH = 0.022;
  const nSteps = Math.max(1, Math.round(bh / stepH));
  const actualStepH = bh / nSteps;

  // ‚îÄ‚îÄ –ü–õ–û–©–ê–î–ö–ê ‚Äî –¥–æ—Å–∫–∏ ‚îÄ‚îÄ
  const boardW = 0.14;
  const gap = 0.005;

  // –î–æ—Å–∫–∏ –Ω–∞ –ø–ª–æ—â–∞–¥–∫–µ: –≤—Å–µ–≥–¥–∞ –ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä–Ω—ã —Å—Ç—É–ø–µ–Ω—è–º
  if (stepDirZ !== 0) {
    // –°—Ç—É–ø–µ–Ω–∏ –∏–¥—É—Ç –ø–æ Z ‚Üí –¥–æ—Å–∫–∏ –∏–¥—É—Ç –ø–æ X
    for (let bx = px + boardW/2; bx <= px + pw; bx += boardW + gap) {
      const b = mesh(box(boardW, boardH, pd), M.deck);
      b.position.set(bx, bh - boardH/2, pz + pd/2);
      porchGroup.add(b);
      threeState.porchMeshes.push(b);
    }
  } else {
    // –°—Ç—É–ø–µ–Ω–∏ –∏–¥—É—Ç –ø–æ X ‚Üí –¥–æ—Å–∫–∏ –∏–¥—É—Ç –ø–æ Z
    for (let bz = pz + boardW/2; bz <= pz + pd; bz += boardW + gap) {
      const b = mesh(box(pw, boardH, boardW), M.deck);
      b.position.set(px + pw/2, bh - boardH/2, bz);
      porchGroup.add(b);
      threeState.porchMeshes.push(b);
    }
  }

  // ‚îÄ‚îÄ –°–¢–£–ü–ï–ù–ò ‚Äî —Å–ø—É—Å–∫–∞—é—Ç—Å—è –æ—Ç –ø–ª–æ—â–∞–¥–∫–∏ –∫ –∑–µ–º–ª–µ ‚îÄ‚îÄ
  for (let i = 0; i < nSteps; i++) {
    const sy = actualStepH;
    const yBot = bh - (i+1) * actualStepH; // —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑
    let sx, sz, sxPos, szPos;

    if (stepDirZ !== 0) {
      // –°—Ç—É–ø–µ–Ω–∏ –ø–æ –æ—Å–∏ Z
      sx = pw; sz = stepD;
      sxPos = px + pw/2;
      szPos = stepDirZ > 0
        ? (pz + pd + i * stepD + stepD/2)    // –≤–ø–µ—Ä—ë–¥ –æ—Ç –ø–ª–æ—â–∞–¥–∫–∏
        : (pz - i * stepD - stepD/2);         // –Ω–∞–∑–∞–¥ –æ—Ç –ø–ª–æ—â–∞–¥–∫–∏
    } else {
      // –°—Ç—É–ø–µ–Ω–∏ –ø–æ –æ—Å–∏ X
      sx = stepD; sz = pd;
      szPos = pz + pd/2;
      sxPos = stepDirX > 0
        ? (px + pw + i * stepD + stepD/2)
        : (px - i * stepD - stepD/2);
    }

    const s = mesh(box(sx, sy, sz), M.step);
    s.position.set(sxPos, yBot + sy/2, szPos);
    porchGroup.add(s);
    threeState.stepMeshes.push(s);
  }

  // ‚îÄ‚îÄ –ë–æ–∫–æ–≤—ã–µ —Å—Ç–µ–Ω–∫–∏ ‚îÄ‚îÄ
  const sideW = 0.06;
  if (stepDirZ !== 0) {
    const ls = mesh(box(sideW, bh, pd), M.base);
    ls.position.set(px, bh/2, pz + pd/2);
    porchGroup.add(ls);
    const rs = mesh(box(sideW, bh, pd), M.base);
    rs.position.set(px + pw, bh/2, pz + pd/2);
    porchGroup.add(rs);
  } else {
    const ls = mesh(box(pw, bh, sideW), M.base);
    ls.position.set(px + pw/2, bh/2, pz);
    porchGroup.add(ls);
    const rs = mesh(box(pw, bh, sideW), M.base);
    rs.position.set(px + pw/2, bh/2, pz + pd);
    porchGroup.add(rs);
  }

  parent.add(porchGroup);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PATHS BUILDER (–¥–æ—Ä–æ–∂–∫–∏)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function buildPaths3d(parent, M, pts, houseL, houseW) {
  if (pts.length < 2) return;
  const worldPts = canvasToWorld(pts, houseL, houseW);
  const pathWidthCm = parseFloat(document.getElementById('v-paths-width')?.value || 120);
  const pathW = pathWidthCm / 100;
  const boardW = 0.14, boardH = 0.022, gap = 0.005;
  const pathGroup = new THREE.Group();
  const box = (sx, sy, sz) => new THREE.BoxGeometry(sx, sy, sz);
  const meshFn = (geo, mat) => { const m = new THREE.Mesh(geo, mat); m.castShadow = true; m.receiveShadow = true; return m; };

  for (let i = 0; i < worldPts.length - 1; i++) {
    const a = worldPts[i], b = worldPts[i+1];
    const dx = b.x - a.x, dz = b.z - a.z;
    const segLen = Math.sqrt(dx*dx + dz*dz);
    if (segLen < 0.1) continue;
    const angle = Math.atan2(dx, dz);
    // –î–æ—Å–∫–∏ –ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä–Ω–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é –¥–æ—Ä–æ–∂–∫–∏
    for (let d = boardW/2; d < segLen; d += boardW + gap) {
      const t = d / segLen;
      const bx = a.x + dx*t, bz = a.z + dz*t;
      const bd = meshFn(box(pathW, boardH, boardW), M.deck);
      bd.position.set(bx, boardH/2, bz);
      bd.rotation.y = angle;
      pathGroup.add(bd);
      threeState.deckMeshes.push(bd);
    }
  }
  parent.add(pathGroup);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FENCE BUILDER (–∑–∞–±–æ—Ä)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function buildFence3d(parent, M, pts, houseL, houseW) {
  if (pts.length < 2) return;
  const worldPts = canvasToWorld(pts, houseL, houseW);
  const fenceH = 1.8, postW = 0.1, postH = fenceH + 0.2;
  const boardW = 0.12, boardH = fenceH - 0.2, boardT = 0.02;
  const fenceGroup = new THREE.Group();
  const box = (sx, sy, sz) => new THREE.BoxGeometry(sx, sy, sz);
  const meshFn = (geo, mat) => { const m = new THREE.Mesh(geo, mat); m.castShadow = true; m.receiveShadow = true; return m; };
  const fenceMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.80, metalness: 0.05 });

  for (let i = 0; i < worldPts.length; i++) {
    // –°—Ç–æ–ª–±
    const p = worldPts[i];
    const post = meshFn(box(postW, postH, postW), M.post);
    post.position.set(p.x, postH/2, p.z);
    fenceGroup.add(post);

    // –°–µ–∫—Ü–∏—è –∑–∞–±–æ—Ä–∞ –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å—Ç–æ–ª–±–∞
    if (i < worldPts.length - 1) {
      const a = worldPts[i], b = worldPts[i+1];
      const dx = b.x - a.x, dz = b.z - a.z;
      const segLen = Math.sqrt(dx*dx + dz*dz);
      if (segLen < 0.2) continue;
      const angle = Math.atan2(dx, dz);
      const mx = (a.x + b.x)/2, mz = (a.z + b.z)/2;
      const panel = meshFn(box(boardT, boardH, segLen - postW), fenceMat);
      panel.position.set(mx, 0.2 + boardH/2, mz);
      panel.rotation.y = angle;
      fenceGroup.add(panel);
      threeState.fenceMeshes.push(panel);
    }
  }
  // –ó–∞–º—ã–∫–∞—é—â–∞—è —Å–µ–∫—Ü–∏—è –µ—Å–ª–∏ 3+ —Ç–æ—á–µ–∫
  if (worldPts.length >= 3) {
    const a = worldPts[worldPts.length-1], b = worldPts[0];
    const dx = b.x - a.x, dz = b.z - a.z;
    const segLen = Math.sqrt(dx*dx + dz*dz);
    if (segLen > 0.2) {
      const angle = Math.atan2(dx, dz);
      const mx = (a.x + b.x)/2, mz = (a.z + b.z)/2;
      const panel = meshFn(box(boardT, boardH, segLen - postW), fenceMat);
      panel.position.set(mx, 0.2 + boardH/2, mz);
      panel.rotation.y = angle;
      fenceGroup.add(panel);
      threeState.fenceMeshes.push(panel);
    }
  }
  parent.add(fenceGroup);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RAILING BUILDER (–æ–≥—Ä–∞–∂–¥–µ–Ω–∏–µ —Ç–µ—Ä—Ä–∞—Å—ã)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function buildRailing3d(parent, M, pts, deckHeight, houseL, houseW) {
  if (pts.length < 3) return;
  const worldPts = canvasToWorld(pts, houseL, houseW);
  const railH = 1.0, railW = 0.05, postW = 0.06;
  const railGroup = new THREE.Group();
  const box = (sx, sy, sz) => new THREE.BoxGeometry(sx, sy, sz);
  const meshFn = (geo, mat) => { const m = new THREE.Mesh(geo, mat); m.castShadow = true; m.receiveShadow = true; return m; };
  const railMat = new THREE.MeshStandardMaterial({ color: 0x777777, roughness: 0.60, metalness: 0.3 });

  // –ó–æ–Ω–∞ –∫—Ä—ã–ª—å—Ü–∞ –≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
  let porchRect = null;
  if (S.sections.includes('porch')) {
    const gridSize = GRID;
    const offsetX = (gridSize - houseL) / 2;
    const offsetZ = (gridSize - houseW) / 2;
    const p = S.porch;
    const px1 = p.x * gridSize - offsetX;
    const pz1 = p.y * gridSize - offsetZ;
    const px2 = (p.x + p.w) * gridSize - offsetX;
    const pz2 = (p.y + p.h) * gridSize - offsetZ;
    porchRect = {
      minX: Math.min(px1, px2), maxX: Math.max(px1, px2),
      minZ: Math.min(pz1, pz2), maxZ: Math.max(pz1, pz2),
    };
  }

  // –†–∞–∑–±–∏–≤–∞–µ—Ç –æ—Ç—Ä–µ–∑–æ–∫ A‚ÜíB –Ω–∞ –ø–æ–¥–æ—Ç—Ä–µ–∑–∫–∏, –≤—ã—Ä–µ–∑–∞—è –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å porchRect
  function splitAroundPorch(ax, az, bx, bz) {
    if (!porchRect) return [{ ax, az, bx, bz }];
    const pr = porchRect;
    const pad = 0.08;
    const dx = bx - ax, dz = bz - az;
    const len = Math.sqrt(dx*dx + dz*dz);
    if (len < 0.01) return [{ ax, az, bx, bz }];

    // –ü–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π t ‚àà [0,1]: P(t) = A + t¬∑(B-A)
    let tEnter = 0, tExit = 1;

    if (Math.abs(dx) > 0.001) {
      const t1 = (pr.minX - pad - ax) / dx;
      const t2 = (pr.maxX + pad - ax) / dx;
      tEnter = Math.max(tEnter, Math.min(t1, t2));
      tExit  = Math.min(tExit,  Math.max(t1, t2));
    } else if (ax < pr.minX - pad || ax > pr.maxX + pad) {
      return [{ ax, az, bx, bz }]; // –º–∏–º–æ –ø–æ X
    }

    if (Math.abs(dz) > 0.001) {
      const t1 = (pr.minZ - pad - az) / dz;
      const t2 = (pr.maxZ + pad - az) / dz;
      tEnter = Math.max(tEnter, Math.min(t1, t2));
      tExit  = Math.min(tExit,  Math.max(t1, t2));
    } else if (az < pr.minZ - pad || az > pr.maxZ + pad) {
      return [{ ax, az, bx, bz }]; // –º–∏–º–æ –ø–æ Z
    }

    if (tEnter >= tExit || tExit <= 0 || tEnter >= 1) return [{ ax, az, bx, bz }];

    const tc0 = Math.max(0, tEnter);
    const tc1 = Math.min(1, tExit);
    const result = [];
    if (tc0 > 0.02)
      result.push({ ax, az, bx: ax + dx*tc0, bz: az + dz*tc0 });
    if (tc1 < 0.98)
      result.push({ ax: ax + dx*tc1, az: az + dz*tc1, bx, bz });
    return result;
  }

  // –†–∏—Å—É–µ—Ç –ø–µ—Ä–∏–ª–∞ –Ω–∞ –ø–æ–¥–æ—Ç—Ä–µ–∑–∫–µ —Å–æ —Å—Ç–æ–ª–±–∏–∫–∞–º–∏ –Ω–∞ –æ–±–æ–∏—Ö –∫–æ–Ω—Ü–∞—Ö
  function drawRailSeg(a_x, a_z, b_x, b_z) {
    const sdx = b_x - a_x, sdz = b_z - a_z;
    const sLen = Math.sqrt(sdx*sdx + sdz*sdz);
    if (sLen < 0.1) return;

    // –°—Ç–æ–ª–±–∏–∫–∏
    for (const [px2, pz2] of [[a_x, a_z], [b_x, b_z]]) {
      const p = meshFn(box(postW, railH, postW), railMat);
      p.position.set(px2, deckHeight + railH/2, pz2);
      railGroup.add(p);
      threeState.railingMeshes.push(p);
    }

    const angle = Math.atan2(sdx, sdz);
    const mx = (a_x + b_x)/2, mz = (a_z + b_z)/2;
    for (const hFrac of [1.0, 0.5]) {
      const bar = meshFn(box(railW, railW, sLen), railMat);
      bar.position.set(mx, deckHeight + railH * hFrac, mz);
      bar.rotation.y = angle;
      railGroup.add(bar);
      threeState.railingMeshes.push(bar);
    }
  }

  for (let i = 0; i < worldPts.length; i++) {
    const cur = worldPts[i];
    const next = worldPts[(i+1) % worldPts.length];
    const subSegs = splitAroundPorch(cur.x, cur.z, next.x, next.z);
    for (const seg of subSegs) {
      drawRailSeg(seg.ax, seg.az, seg.bx, seg.bz);
    }
  }
  parent.add(railGroup);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MATERIAL APPLICATION (–ø—Ä–∏–º–µ—Ä–∫–∞)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function applyMaterialToScene(colorHex) {
  if (!threeState || !colorHex) return;
  const c = new THREE.Color(colorHex);

  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ–∫—É—â—É—é —Å–µ–∫—Ü–∏—é
  const sec = getActive()[S.curSec];
  const secId = sec ? sec.id : 'terrace';

  let targetMeshes = [];
  let roughness = 0.72;

  if (secId === 'facade') {
    targetMeshes = threeState.wallMeshes || [];
    roughness = 0.85;
  } else if (secId === 'porch') {
    targetMeshes = threeState.stepMeshes || [];
    roughness = 0.80;
  } else if (secId === 'fence') {
    targetMeshes = threeState.fenceMeshes || [];
    roughness = 0.80;
  } else {
    // terrace, pool_terrace, pier, paths, beds, furniture ‚Üí –¥–æ—Å–∫–∏ –Ω–∞—Å—Ç–∏–ª–∞
    targetMeshes = [...(threeState.deckMeshes||[]), ...(threeState.porchMeshes||[])];
  }

  if (targetMeshes.length === 0) {
    buildScene3d();
    return;
  }

  const newMat = new THREE.MeshStandardMaterial({ color: c, roughness, metalness: 0.02 });
  targetMeshes.forEach(m => {
    if (m.material) m.material.dispose();
    m.material = newMat;
  });
}

function rot(dir) { /* orbit controls handle rotation, kept for compat */ }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// –°–ï–ö–¶–ò–ò –ú–ê–¢–ï–†–ò–ê–õ–û–í (–®–ê–ì 10)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function getActive() {
  return SECS.filter(s => S.sections.length===0 || S.sections.includes(s.req));
}
function renderSec() {
  const active=getActive(); if (!active.length) return;
  if (S.curSec>=active.length) S.curSec=0;
  const sec=active[S.curSec];
  document.getElementById('sec-title').textContent=sec.lbl;
  document.getElementById('sec-nav').innerHTML=active.map((s,i)=>
    `<div class="sec-tab ${i===S.curSec?'active':''}" onclick="switchSec(${i})">${s.lbl}</div>`
  ).join('');
  renderSwatches();
}
function renderSwatches() {
  const grid = document.getElementById('samples-grid');
  const lbl  = document.getElementById('sample-lbl');
  const all  = S.samples; // –º–∞—Å—Å–∏–≤ {id, name, color}
  if (!all || !all.length) {
    grid.innerHTML = '<span class="samples-empty">–î–æ–±–∞–≤—å—Ç–µ –æ–±—Ä–∞–∑—Ü—ã –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞</span>';
    lbl.textContent = '–û–±—Ä–∞–∑—Ü—ã:';
    return;
  }
  lbl.textContent = `–û–±—Ä–∞–∑—Ü—ã (${all.length}):`;
  grid.innerHTML = all.map((s,i) => `
    <div class="swatch ${S.activeSample && S.activeSample.id===s.id && S.activeSample._idx===i ? 'swatch-active':''}"
         title="${s.name}" onclick="applySwatch(${i})"
         style="background:${s.color || '#d9d9d9'}; cursor:pointer;">
      <button class="swatch-del" onclick="event.stopPropagation(); removeSwatch(${i})">‚úï</button>
      <span class="swatch-name" style="color:${isLightColor(s.color)?'#333':'#fff'}">${s.name}</span>
    </div>`).join('');
}

function isLightColor(hex) {
  if (!hex) return true;
  const c = hex.replace('#','');
  const r = parseInt(c.substr(0,2),16), g = parseInt(c.substr(2,2),16), b = parseInt(c.substr(4,2),16);
  return (r*0.299 + g*0.587 + b*0.114) > 150;
}

function applySwatch(idx) {
  const s = S.samples[idx];
  if (!s || !s.color) return;
  S.activeSample = { ...s, _idx: idx };

  // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ü–≤–µ—Ç –∫ mesh'–∞–º —Ç–µ–∫—É—â–µ–π —Å–µ–∫—Ü–∏–∏
  if (threeState) {
    applyMaterialToScene(s.color);
  }

  // –û–±–Ω–æ–≤–ª—è–µ–º UI (–ø–æ–¥—Å–≤–µ—Ç–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ)
  renderSwatches();
}
function removeSwatch(i) {
  S.samples.splice(i,1);
  renderSwatches();
}
function switchSec(i) { S.curSec=i; renderSec(); }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// –ö–ê–¢–ê–õ–û–ì ‚Äî –§–ò–õ–¨–¢–†–´ –ò –†–ï–ó–£–õ–¨–¢–ê–¢–´
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function openCatalog() {
  S.catShowResults=false;
  S.catColors=new Set(); S.catPrice=null;
  document.getElementById('screen-'+step).classList.remove('active');
  step='catalog';
  document.getElementById('screen-catalog').classList.add('active');
  // –ö–Ω–æ–ø–∫–∞ –Ω–∞–∑–∞–¥ –≤—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫ —à–∞–≥—É 10
  document.getElementById('cat-back-btn').onclick = () => goTo(10);
  renderCatalogFilters();
  document.getElementById('plbl').textContent='–ö–∞—Ç–∞–ª–æ–≥';
}

function renderCatalogFilters() {
  S.catShowResults=false;
  document.getElementById('cat-title').textContent='–¢–µ—Ä—Ä–∞—Å–Ω–∞—è –¥–æ—Å–∫–∞';
  document.getElementById('cat-action-btn').textContent='–ü–û–î–û–ë–†–ê–¢–¨ ‚Üí';
  document.getElementById('cat-action-btn').onclick=showCatalogResults;
  document.getElementById('cat-back-btn').onclick = () => goTo(10);

  document.getElementById('cat-body').innerHTML=`
    <div class="filter-section">
      <div class="filter-title">–¶–≤–µ—Ç (–º–æ–∂–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ):</div>
      <div class="color-grid" id="color-grid">
        ${CATALOG_COLORS.map(c=>`
          <div class="color-dot" id="cd-${c.id}" title="${c.label}"
               style="background:${c.hex};"
               onclick="toggleColor('${c.id}')"></div>`).join('')}
      </div>
    </div>
    <div class="filter-divider"></div>
    <div class="filter-section">
      <div class="filter-title">–¶–µ–Ω–æ–≤–æ–π –¥–∏–∞–ø–∞–∑–æ–Ω:</div>
      <div class="price-btns" id="price-btns">
        ${PRICE_TIERS.map(t=>`
          <button class="price-btn" id="pb-${t.id}" onclick="selectPrice('${t.id}')">
            ${t.lbl}<br><span style="font-size:11px;font-weight:400;opacity:.7">${t.sub}</span>
          </button>`).join('')}
      </div>
    </div>
  `;
}

function toggleColor(cid) {
  if (S.catColors.has(cid)) S.catColors.delete(cid);
  else S.catColors.add(cid);
  document.querySelectorAll('.color-dot').forEach(el => {
    el.classList.toggle('selected', S.catColors.has(el.id.replace('cd-','')));
  });
}

function selectPrice(tid) {
  S.catPrice = S.catPrice===tid ? null : tid;
  document.querySelectorAll('.price-btn').forEach(el =>
    el.classList.toggle('selected', el.id==='pb-'+S.catPrice));
}

function showCatalogResults() {
  let results = [...STUB_RESULTS];

  if (S.catPrice === 'budget')        results = results.filter(r => r.id === 4);
  else if (S.catPrice === 'balanced') results = results.filter(r => [1,4].includes(r.id));
  else if (S.catPrice === 'premium')  results = results.filter(r => [2,3].includes(r.id));
  else if (S.catPrice === 'mpk')      results = [{
    id:99,
    name:'Deckron –ú–ü–ö –ö–ª–∞—Å—Å–∏–∫ 145√ó22',
    short:'–ú–∞—Å—Å–∏–≤ –ø—Ä–µ—Å—Å–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–µ–¥—Ä–∞, –ø—Ä–µ–º–∏—É–º',
    detail:'–ú–∞—Å—Å–∏–≤ –ø—Ä–µ—Å—Å–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–µ–¥—Ä–∞ (–ú–ü–ö) ‚Äî –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã–π –∫–µ–¥—Ä –ø–æ–¥ –¥–∞–≤–ª–µ–Ω–∏–µ–º 800 –∞—Ç–º. –ü–ª–æ—Ç–Ω–æ—Å—Ç—å –≤—ã—à–µ –¥—É–±–∞. –ù–µ –≥–Ω–∏—ë—Ç, –Ω–µ —Ç—Ä–µ—Å–∫–∞–µ—Ç—Å—è, –Ω–µ —Ç—Ä–µ–±—É–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏. –¶–≤–µ—Ç —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è 30+ –ª–µ—Ç. –°—Ä–æ–∫ —Å–ª—É–∂–±—ã –Ω–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω.',
    price:'–æ—Ç 10 000 ‚ÇΩ/–º¬≤',
    color:'#A0522D',
    url:'https://outdoor-mebel.ru/catalog/terrasnaya_doska_iz_dpk/doska_dpk_universalnaya/deckron',
  }];

  S.catShowResults = true;
  document.getElementById('cat-title').textContent = `–†–µ–∑—É–ª—å—Ç–∞—Ç—ã (${results.length})`;
  // –ö–Ω–æ–ø–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è —Ç–µ–ø–µ—Ä—å –≤–µ–¥—ë—Ç –∫ –ø—Ä–∏–º–µ—Ä–∫–µ
  document.getElementById('cat-action-btn').textContent = '–ö –ü–†–ò–ú–ï–†–ö–ï ‚Üí';
  document.getElementById('cat-action-btn').onclick = () => goTo(10);
  // –ö–Ω–æ–ø–∫–∞ –Ω–∞–∑–∞–¥ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫ —Ñ–∏–ª—å—Ç—Ä–∞–º
  document.getElementById('cat-back-btn').onclick = () => {
    renderCatalogFilters();
    document.getElementById('cat-action-btn').textContent = '–ü–û–î–û–ë–†–ê–¢–¨ ‚Üí';
    document.getElementById('cat-action-btn').onclick = showCatalogResults;
    document.getElementById('cat-back-btn').onclick = () => goTo(10);
  };

  document.getElementById('cat-body').innerHTML = `
    <div class="cat-results">
      ${results.map(m => `
        <div class="mat-card" id="mc-${m.id}">
          <div class="mat-head" onclick="toggleCard(${m.id})">
            <div class="mat-thumb" style="background:${m.color||'#bbb'}"></div>
            <div class="mat-hi">
              <div class="mat-name">${m.name}</div>
              <div class="mat-short">${m.short}</div>
              <div style="font-size:13px;font-weight:700;margin-top:4px;color:#333">${m.price}</div>
            </div>
            <button class="mat-exp">‚ñº</button>
          </div>
          <div class="mat-body"><div class="mat-bi">
            <div class="mat-det">${m.detail}</div>
            <div class="mat-acts">
              <button class="btn-smp" onclick="selMat(event,${m.id},'${m.name.replace(/'/g,"\\'")}','${m.color||'#C8A96E'}')">+ –í –æ–±—Ä–∞–∑—Ü—ã</button>
            </div>
            <a href="${m.url}" target="_blank"
               style="display:block;margin-top:10px;font-size:12px;color:#555;text-decoration:underline;">
              –ü–æ–¥—Ä–æ–±–Ω–µ–µ –Ω–∞ outdoor-mebel.ru ‚Üó
            </a>
          </div></div>
        </div>`).join('')}
    </div>`;
}

function toggleCard(mid) {
  const el=document.getElementById('mc-'+mid);
  const was=el.classList.contains('open');
  document.querySelectorAll('.mat-card.open').forEach(c=>c.classList.remove('open'));
  if (!was) el.classList.add('open');
}
function selMat(e, mid, name, color) {
  // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–∑–µ—Ü —Å —Ü–≤–µ—Ç–æ–º
  S.samples.push({id: mid, name, color});
  // –í–∏–∑—É–∞–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å: –∫–Ω–æ–ø–∫–∞ –º–∏–≥–∞–µ—Ç
  const btn = e.currentTarget;
  const orig = btn.textContent;
  btn.textContent = '‚úì –î–æ–±–∞–≤–ª–µ–Ω–æ';
  btn.style.background = '#444';
  setTimeout(()=>{ btn.textContent = orig; btn.style.background = '#000'; }, 800);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// –ò–¢–û–ì
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function showSummary() {
  const rows=[
    ['–¢–∏–ø –¥–æ–º–∞', S.houseType||'–Ω–µ –≤—ã–±—Ä–∞–Ω'],
    ['–ü–ª–æ—â–∞–¥—å', (document.getElementById('v-area')?.value||'‚Äî')+' –∫–≤.–º'],
    ['–í—ã—Å–æ—Ç–∞ —ç—Ç–∞–∂–∞', (document.getElementById('v-floor')?.value||'‚Äî')+' —Å–º'],
    ['–§—É–Ω–¥–∞–º–µ–Ω—Ç', (document.getElementById('v-found')?.value||'‚Äî')+' —Å–º'],
    ['–ß—Ç–æ —Å—Ç—Ä–æ–∏–º', S.sections.length?S.sections.map(s=>SECS.find(x=>x.id===s)?.lbl||s).join(', '):'–Ω–µ –≤—ã–±—Ä–∞–Ω–æ'],
    ...Object.entries(S.mats).map(([k,v])=>[SECS.find(s=>s.id===k)?.lbl||k, v.name]),
  ];
  document.getElementById('sum-body').innerHTML=rows.map(([k,v])=>
    `<div class="sum-row"><span class="sum-k">${k}</span><span class="sum-v">${v}</span></div>`
  ).join('');
  const prev=document.getElementById('screen-'+step);
  if (prev) prev.classList.remove('active');
  step='summary';
  document.getElementById('screen-summary').classList.add('active');
  document.getElementById('pfill').style.width='100%';
  document.getElementById('plbl').textContent='–ì–æ—Ç–æ–≤–æ!';
}

// Resize Three.js when app window size changes
window.addEventListener('resize', () => { resizeThree(); });
</script>
</body>
</html>
